// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/state_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { CreatedEvent } from "./event";
import { AssignedEvent, UnassignedEvent } from "./reassignment";
import { EventFormat, TransactionFilter } from "./transaction_filter";

export const protobufPackage = "com.daml.ledger.api.v2";

/**
 * Enum indicating the permission level that the participant has for the party
 * whose connected synchronizers are being listed.
 */
export enum ParticipantPermission {
  PARTICIPANT_PERMISSION_UNSPECIFIED = 0,
  PARTICIPANT_PERMISSION_SUBMISSION = 1,
  /** PARTICIPANT_PERMISSION_CONFIRMATION - participant can only confirm transactions */
  PARTICIPANT_PERMISSION_CONFIRMATION = 2,
  /** PARTICIPANT_PERMISSION_OBSERVATION - participant can only observe transactions */
  PARTICIPANT_PERMISSION_OBSERVATION = 3,
  UNRECOGNIZED = -1,
}

export function participantPermissionFromJSON(object: any): ParticipantPermission {
  switch (object) {
    case 0:
    case "PARTICIPANT_PERMISSION_UNSPECIFIED":
      return ParticipantPermission.PARTICIPANT_PERMISSION_UNSPECIFIED;
    case 1:
    case "PARTICIPANT_PERMISSION_SUBMISSION":
      return ParticipantPermission.PARTICIPANT_PERMISSION_SUBMISSION;
    case 2:
    case "PARTICIPANT_PERMISSION_CONFIRMATION":
      return ParticipantPermission.PARTICIPANT_PERMISSION_CONFIRMATION;
    case 3:
    case "PARTICIPANT_PERMISSION_OBSERVATION":
      return ParticipantPermission.PARTICIPANT_PERMISSION_OBSERVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipantPermission.UNRECOGNIZED;
  }
}

export function participantPermissionToJSON(object: ParticipantPermission): string {
  switch (object) {
    case ParticipantPermission.PARTICIPANT_PERMISSION_UNSPECIFIED:
      return "PARTICIPANT_PERMISSION_UNSPECIFIED";
    case ParticipantPermission.PARTICIPANT_PERMISSION_SUBMISSION:
      return "PARTICIPANT_PERMISSION_SUBMISSION";
    case ParticipantPermission.PARTICIPANT_PERMISSION_CONFIRMATION:
      return "PARTICIPANT_PERMISSION_CONFIRMATION";
    case ParticipantPermission.PARTICIPANT_PERMISSION_OBSERVATION:
      return "PARTICIPANT_PERMISSION_OBSERVATION";
    case ParticipantPermission.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
 * the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
 * Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
 * migration is not concerned with incomplete (un)assignments.
 */
export interface GetActiveContractsRequest {
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Templates to include in the served snapshot, per party.
   * Optional, if specified event_format must be unset, if not specified event_format must be set.
   */
  filter:
    | TransactionFilter
    | undefined;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
   * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
   * Optional, if specified event_format must be unset.
   */
  verbose: boolean;
  /**
   * The offset at which the snapshot of the active contracts will be computed.
   * Must be no greater than the current ledger end offset.
   * Must be greater than or equal to the last pruning offset.
   * Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
   * If zero, the empty set will be returned.
   */
  activeAtOffset: number;
  /**
   * Format of the contract_entries in the result. In case of CreatedEvent the presentation will be of
   * TRANSACTION_SHAPE_ACS_DELTA.
   * Optional for backwards compatibility, defaults to an EventFormat where:
   *
   * - filters_by_party is the filter.filters_by_party from this request
   * - filters_for_any_party is the filter.filters_for_any_party from this request
   * - verbose is the verbose field from this request
   */
  eventFormat: EventFormat | undefined;
}

export interface GetActiveContractsResponse {
  /**
   * The workflow ID used in command submission which corresponds to the contract_entry. Only set if
   * the ``workflow_id`` for the command was set.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Optional
   */
  workflowId: string;
  /**
   * The contract is active on the assigned synchronizer, meaning: there was an activation event on the given synchronizer (
   * created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same
   * synchronizer, until the active_at_offset.
   * Since activeness is defined as a per synchronizer concept, it is possible, that a contract is active on one
   * synchronizer, but already archived on another.
   * There will be one such message for each synchronizer the contract is active on.
   */
  activeContract?:
    | ActiveContract
    | undefined;
  /**
   * Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding
   * assigned event before or at the active_at_offset.
   */
  incompleteUnassigned?:
    | IncompleteUnassigned
    | undefined;
  /**
   * Important: this message is not indicating that the contract is active on the target synchronizer!
   * Included iff the assigned event was before or at the active_at_offset, but there was no corresponding
   * unassigned event before or at the active_at_offset.
   */
  incompleteAssigned?: IncompleteAssigned | undefined;
}

export interface ActiveContract {
  /**
   * Required
   * The event as it appeared in the context of its last update (i.e. daml transaction or
   * reassignment). In particular, the last offset, node_id pair is preserved.
   * The last update is the most recent update created or assigned this contract on synchronizer_id synchronizer.
   * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
   * for lookups.
   */
  createdEvent:
    | CreatedEvent
    | undefined;
  /**
   * A valid synchronizer id
   * Required
   */
  synchronizerId: string;
  /**
   * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
   * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
   * equals zero.
   * This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
   * before the active_at_offset.
   * Required
   */
  reassignmentCounter: number;
}

export interface IncompleteUnassigned {
  /**
   * Required
   * The event as it appeared in the context of its last activation update (i.e. daml transaction or
   * reassignment). In particular, the last activation offset, node_id pair is preserved.
   * The last activation update is the most recent update created or assigned this contract on synchronizer_id synchronizer before
   * the unassigned_event.
   * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
   * for lookups.
   */
  createdEvent:
    | CreatedEvent
    | undefined;
  /** Required */
  unassignedEvent: UnassignedEvent | undefined;
}

export interface IncompleteAssigned {
  /** Required */
  assignedEvent: AssignedEvent | undefined;
}

export interface GetConnectedSynchronizersRequest {
  /**
   * The party of interest
   * Must be a valid PartyIdString (as described in ``value.proto``).
   * Required
   */
  party: string;
  /**
   * The id of a participant whose mapping of a party to connected synchronizers is requested.
   * Must be a valid participant-id retrieved through a prior call to getParticipantId.
   * Defaults to the participant id of the host participant.
   * Optional
   */
  participantId: string;
}

export interface GetConnectedSynchronizersResponse {
  connectedSynchronizers: GetConnectedSynchronizersResponse_ConnectedSynchronizer[];
}

export interface GetConnectedSynchronizersResponse_ConnectedSynchronizer {
  /**
   * The alias of the synchronizer
   * Required
   */
  synchronizerAlias: string;
  /**
   * The ID of the synchronizer
   * Required
   */
  synchronizerId: string;
  /**
   * The permission on the synchronizer
   * Required
   */
  permission: ParticipantPermission;
}

export interface GetLedgerEndRequest {
}

export interface GetLedgerEndResponse {
  /**
   * It will always be a non-negative integer.
   * If zero, the participant view of the ledger is empty.
   * If positive, the absolute offset of the ledger as viewed by the participant.
   */
  offset: number;
}

/** Empty for now, but may contain fields in the future. */
export interface GetLatestPrunedOffsetsRequest {
}

export interface GetLatestPrunedOffsetsResponse {
  /**
   * It will always be a non-negative integer.
   * If positive, the absolute offset up to which the ledger has been pruned,
   * disregarding the state of all divulged contracts pruning.
   * If zero, the ledger has not been pruned yet.
   */
  participantPrunedUpToInclusive: number;
  /**
   * It will always be a non-negative integer.
   * If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
   * It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
   * For more details about all divulged events pruning,
   * see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
   * If zero, the divulged events have not been pruned yet.
   */
  allDivulgedContractsPrunedUpToInclusive: number;
}

function createBaseGetActiveContractsRequest(): GetActiveContractsRequest {
  return { filter: undefined, verbose: false, activeAtOffset: 0, eventFormat: undefined };
}

export const GetActiveContractsRequest: MessageFns<GetActiveContractsRequest> = {
  encode(message: GetActiveContractsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      TransactionFilter.encode(message.filter, writer.uint32(10).fork()).join();
    }
    if (message.verbose !== false) {
      writer.uint32(16).bool(message.verbose);
    }
    if (message.activeAtOffset !== 0) {
      writer.uint32(24).int64(message.activeAtOffset);
    }
    if (message.eventFormat !== undefined) {
      EventFormat.encode(message.eventFormat, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveContractsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveContractsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = TransactionFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeAtOffset = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventFormat = EventFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveContractsRequest {
    return {
      filter: isSet(object.filter) ? TransactionFilter.fromJSON(object.filter) : undefined,
      verbose: isSet(object.verbose) ? gt.Boolean(object.verbose) : false,
      activeAtOffset: isSet(object.activeAtOffset) ? gt.Number(object.activeAtOffset) : 0,
      eventFormat: isSet(object.eventFormat) ? EventFormat.fromJSON(object.eventFormat) : undefined,
    };
  },

  toJSON(message: GetActiveContractsRequest): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = TransactionFilter.toJSON(message.filter);
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    if (message.activeAtOffset !== 0) {
      obj.activeAtOffset = Math.round(message.activeAtOffset);
    }
    if (message.eventFormat !== undefined) {
      obj.eventFormat = EventFormat.toJSON(message.eventFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveContractsRequest>, I>>(base?: I): GetActiveContractsRequest {
    return GetActiveContractsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveContractsRequest>, I>>(object: I): GetActiveContractsRequest {
    const message = createBaseGetActiveContractsRequest();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? TransactionFilter.fromPartial(object.filter)
      : undefined;
    message.verbose = object.verbose ?? false;
    message.activeAtOffset = object.activeAtOffset ?? 0;
    message.eventFormat = (object.eventFormat !== undefined && object.eventFormat !== null)
      ? EventFormat.fromPartial(object.eventFormat)
      : undefined;
    return message;
  },
};

function createBaseGetActiveContractsResponse(): GetActiveContractsResponse {
  return { workflowId: "", activeContract: undefined, incompleteUnassigned: undefined, incompleteAssigned: undefined };
}

export const GetActiveContractsResponse: MessageFns<GetActiveContractsResponse> = {
  encode(message: GetActiveContractsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.activeContract !== undefined) {
      ActiveContract.encode(message.activeContract, writer.uint32(18).fork()).join();
    }
    if (message.incompleteUnassigned !== undefined) {
      IncompleteUnassigned.encode(message.incompleteUnassigned, writer.uint32(26).fork()).join();
    }
    if (message.incompleteAssigned !== undefined) {
      IncompleteAssigned.encode(message.incompleteAssigned, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveContractsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveContractsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeContract = ActiveContract.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.incompleteUnassigned = IncompleteUnassigned.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.incompleteAssigned = IncompleteAssigned.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveContractsResponse {
    return {
      workflowId: isSet(object.workflowId) ? gt.String(object.workflowId) : "",
      activeContract: isSet(object.activeContract) ? ActiveContract.fromJSON(object.activeContract) : undefined,
      incompleteUnassigned: isSet(object.incompleteUnassigned)
        ? IncompleteUnassigned.fromJSON(object.incompleteUnassigned)
        : undefined,
      incompleteAssigned: isSet(object.incompleteAssigned)
        ? IncompleteAssigned.fromJSON(object.incompleteAssigned)
        : undefined,
    };
  },

  toJSON(message: GetActiveContractsResponse): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.activeContract !== undefined) {
      obj.activeContract = ActiveContract.toJSON(message.activeContract);
    }
    if (message.incompleteUnassigned !== undefined) {
      obj.incompleteUnassigned = IncompleteUnassigned.toJSON(message.incompleteUnassigned);
    }
    if (message.incompleteAssigned !== undefined) {
      obj.incompleteAssigned = IncompleteAssigned.toJSON(message.incompleteAssigned);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveContractsResponse>, I>>(base?: I): GetActiveContractsResponse {
    return GetActiveContractsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveContractsResponse>, I>>(object: I): GetActiveContractsResponse {
    const message = createBaseGetActiveContractsResponse();
    message.workflowId = object.workflowId ?? "";
    message.activeContract = (object.activeContract !== undefined && object.activeContract !== null)
      ? ActiveContract.fromPartial(object.activeContract)
      : undefined;
    message.incompleteUnassigned = (object.incompleteUnassigned !== undefined && object.incompleteUnassigned !== null)
      ? IncompleteUnassigned.fromPartial(object.incompleteUnassigned)
      : undefined;
    message.incompleteAssigned = (object.incompleteAssigned !== undefined && object.incompleteAssigned !== null)
      ? IncompleteAssigned.fromPartial(object.incompleteAssigned)
      : undefined;
    return message;
  },
};

function createBaseActiveContract(): ActiveContract {
  return { createdEvent: undefined, synchronizerId: "", reassignmentCounter: 0 };
}

export const ActiveContract: MessageFns<ActiveContract> = {
  encode(message: ActiveContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdEvent !== undefined) {
      CreatedEvent.encode(message.createdEvent, writer.uint32(10).fork()).join();
    }
    if (message.synchronizerId !== "") {
      writer.uint32(18).string(message.synchronizerId);
    }
    if (message.reassignmentCounter !== 0) {
      writer.uint32(24).uint64(message.reassignmentCounter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createdEvent = CreatedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reassignmentCounter = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveContract {
    return {
      createdEvent: isSet(object.createdEvent) ? CreatedEvent.fromJSON(object.createdEvent) : undefined,
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      reassignmentCounter: isSet(object.reassignmentCounter) ? gt.Number(object.reassignmentCounter) : 0,
    };
  },

  toJSON(message: ActiveContract): unknown {
    const obj: any = {};
    if (message.createdEvent !== undefined) {
      obj.createdEvent = CreatedEvent.toJSON(message.createdEvent);
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.reassignmentCounter !== 0) {
      obj.reassignmentCounter = Math.round(message.reassignmentCounter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActiveContract>, I>>(base?: I): ActiveContract {
    return ActiveContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActiveContract>, I>>(object: I): ActiveContract {
    const message = createBaseActiveContract();
    message.createdEvent = (object.createdEvent !== undefined && object.createdEvent !== null)
      ? CreatedEvent.fromPartial(object.createdEvent)
      : undefined;
    message.synchronizerId = object.synchronizerId ?? "";
    message.reassignmentCounter = object.reassignmentCounter ?? 0;
    return message;
  },
};

function createBaseIncompleteUnassigned(): IncompleteUnassigned {
  return { createdEvent: undefined, unassignedEvent: undefined };
}

export const IncompleteUnassigned: MessageFns<IncompleteUnassigned> = {
  encode(message: IncompleteUnassigned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdEvent !== undefined) {
      CreatedEvent.encode(message.createdEvent, writer.uint32(10).fork()).join();
    }
    if (message.unassignedEvent !== undefined) {
      UnassignedEvent.encode(message.unassignedEvent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncompleteUnassigned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncompleteUnassigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createdEvent = CreatedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unassignedEvent = UnassignedEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncompleteUnassigned {
    return {
      createdEvent: isSet(object.createdEvent) ? CreatedEvent.fromJSON(object.createdEvent) : undefined,
      unassignedEvent: isSet(object.unassignedEvent) ? UnassignedEvent.fromJSON(object.unassignedEvent) : undefined,
    };
  },

  toJSON(message: IncompleteUnassigned): unknown {
    const obj: any = {};
    if (message.createdEvent !== undefined) {
      obj.createdEvent = CreatedEvent.toJSON(message.createdEvent);
    }
    if (message.unassignedEvent !== undefined) {
      obj.unassignedEvent = UnassignedEvent.toJSON(message.unassignedEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncompleteUnassigned>, I>>(base?: I): IncompleteUnassigned {
    return IncompleteUnassigned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncompleteUnassigned>, I>>(object: I): IncompleteUnassigned {
    const message = createBaseIncompleteUnassigned();
    message.createdEvent = (object.createdEvent !== undefined && object.createdEvent !== null)
      ? CreatedEvent.fromPartial(object.createdEvent)
      : undefined;
    message.unassignedEvent = (object.unassignedEvent !== undefined && object.unassignedEvent !== null)
      ? UnassignedEvent.fromPartial(object.unassignedEvent)
      : undefined;
    return message;
  },
};

function createBaseIncompleteAssigned(): IncompleteAssigned {
  return { assignedEvent: undefined };
}

export const IncompleteAssigned: MessageFns<IncompleteAssigned> = {
  encode(message: IncompleteAssigned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assignedEvent !== undefined) {
      AssignedEvent.encode(message.assignedEvent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncompleteAssigned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncompleteAssigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assignedEvent = AssignedEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncompleteAssigned {
    return { assignedEvent: isSet(object.assignedEvent) ? AssignedEvent.fromJSON(object.assignedEvent) : undefined };
  },

  toJSON(message: IncompleteAssigned): unknown {
    const obj: any = {};
    if (message.assignedEvent !== undefined) {
      obj.assignedEvent = AssignedEvent.toJSON(message.assignedEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncompleteAssigned>, I>>(base?: I): IncompleteAssigned {
    return IncompleteAssigned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncompleteAssigned>, I>>(object: I): IncompleteAssigned {
    const message = createBaseIncompleteAssigned();
    message.assignedEvent = (object.assignedEvent !== undefined && object.assignedEvent !== null)
      ? AssignedEvent.fromPartial(object.assignedEvent)
      : undefined;
    return message;
  },
};

function createBaseGetConnectedSynchronizersRequest(): GetConnectedSynchronizersRequest {
  return { party: "", participantId: "" };
}

export const GetConnectedSynchronizersRequest: MessageFns<GetConnectedSynchronizersRequest> = {
  encode(message: GetConnectedSynchronizersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.party !== "") {
      writer.uint32(10).string(message.party);
    }
    if (message.participantId !== "") {
      writer.uint32(18).string(message.participantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedSynchronizersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedSynchronizersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.party = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectedSynchronizersRequest {
    return {
      party: isSet(object.party) ? gt.String(object.party) : "",
      participantId: isSet(object.participantId) ? gt.String(object.participantId) : "",
    };
  },

  toJSON(message: GetConnectedSynchronizersRequest): unknown {
    const obj: any = {};
    if (message.party !== "") {
      obj.party = message.party;
    }
    if (message.participantId !== "") {
      obj.participantId = message.participantId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectedSynchronizersRequest>, I>>(
    base?: I,
  ): GetConnectedSynchronizersRequest {
    return GetConnectedSynchronizersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectedSynchronizersRequest>, I>>(
    object: I,
  ): GetConnectedSynchronizersRequest {
    const message = createBaseGetConnectedSynchronizersRequest();
    message.party = object.party ?? "";
    message.participantId = object.participantId ?? "";
    return message;
  },
};

function createBaseGetConnectedSynchronizersResponse(): GetConnectedSynchronizersResponse {
  return { connectedSynchronizers: [] };
}

export const GetConnectedSynchronizersResponse: MessageFns<GetConnectedSynchronizersResponse> = {
  encode(message: GetConnectedSynchronizersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connectedSynchronizers) {
      GetConnectedSynchronizersResponse_ConnectedSynchronizer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedSynchronizersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedSynchronizersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectedSynchronizers.push(
            GetConnectedSynchronizersResponse_ConnectedSynchronizer.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectedSynchronizersResponse {
    return {
      connectedSynchronizers: gt.Array.isArray(object?.connectedSynchronizers)
        ? object.connectedSynchronizers.map((e: any) =>
          GetConnectedSynchronizersResponse_ConnectedSynchronizer.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: GetConnectedSynchronizersResponse): unknown {
    const obj: any = {};
    if (message.connectedSynchronizers?.length) {
      obj.connectedSynchronizers = message.connectedSynchronizers.map((e) =>
        GetConnectedSynchronizersResponse_ConnectedSynchronizer.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectedSynchronizersResponse>, I>>(
    base?: I,
  ): GetConnectedSynchronizersResponse {
    return GetConnectedSynchronizersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectedSynchronizersResponse>, I>>(
    object: I,
  ): GetConnectedSynchronizersResponse {
    const message = createBaseGetConnectedSynchronizersResponse();
    message.connectedSynchronizers =
      object.connectedSynchronizers?.map((e) =>
        GetConnectedSynchronizersResponse_ConnectedSynchronizer.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseGetConnectedSynchronizersResponse_ConnectedSynchronizer(): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
  return { synchronizerAlias: "", synchronizerId: "", permission: 0 };
}

export const GetConnectedSynchronizersResponse_ConnectedSynchronizer: MessageFns<
  GetConnectedSynchronizersResponse_ConnectedSynchronizer
> = {
  encode(
    message: GetConnectedSynchronizersResponse_ConnectedSynchronizer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.synchronizerAlias !== "") {
      writer.uint32(10).string(message.synchronizerAlias);
    }
    if (message.synchronizerId !== "") {
      writer.uint32(18).string(message.synchronizerId);
    }
    if (message.permission !== 0) {
      writer.uint32(24).int32(message.permission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedSynchronizersResponse_ConnectedSynchronizer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.synchronizerAlias = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permission = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
    return {
      synchronizerAlias: isSet(object.synchronizerAlias) ? gt.String(object.synchronizerAlias) : "",
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      permission: isSet(object.permission) ? participantPermissionFromJSON(object.permission) : 0,
    };
  },

  toJSON(message: GetConnectedSynchronizersResponse_ConnectedSynchronizer): unknown {
    const obj: any = {};
    if (message.synchronizerAlias !== "") {
      obj.synchronizerAlias = message.synchronizerAlias;
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.permission !== 0) {
      obj.permission = participantPermissionToJSON(message.permission);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConnectedSynchronizersResponse_ConnectedSynchronizer>, I>>(
    base?: I,
  ): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
    return GetConnectedSynchronizersResponse_ConnectedSynchronizer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConnectedSynchronizersResponse_ConnectedSynchronizer>, I>>(
    object: I,
  ): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
    const message = createBaseGetConnectedSynchronizersResponse_ConnectedSynchronizer();
    message.synchronizerAlias = object.synchronizerAlias ?? "";
    message.synchronizerId = object.synchronizerId ?? "";
    message.permission = object.permission ?? 0;
    return message;
  },
};

function createBaseGetLedgerEndRequest(): GetLedgerEndRequest {
  return {};
}

export const GetLedgerEndRequest: MessageFns<GetLedgerEndRequest> = {
  encode(_: GetLedgerEndRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerEndRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerEndRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLedgerEndRequest {
    return {};
  },

  toJSON(_: GetLedgerEndRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerEndRequest>, I>>(base?: I): GetLedgerEndRequest {
    return GetLedgerEndRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerEndRequest>, I>>(_: I): GetLedgerEndRequest {
    const message = createBaseGetLedgerEndRequest();
    return message;
  },
};

function createBaseGetLedgerEndResponse(): GetLedgerEndResponse {
  return { offset: 0 };
}

export const GetLedgerEndResponse: MessageFns<GetLedgerEndResponse> = {
  encode(message: GetLedgerEndResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerEndResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerEndResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLedgerEndResponse {
    return { offset: isSet(object.offset) ? gt.Number(object.offset) : 0 };
  },

  toJSON(message: GetLedgerEndResponse): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerEndResponse>, I>>(base?: I): GetLedgerEndResponse {
    return GetLedgerEndResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerEndResponse>, I>>(object: I): GetLedgerEndResponse {
    const message = createBaseGetLedgerEndResponse();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseGetLatestPrunedOffsetsRequest(): GetLatestPrunedOffsetsRequest {
  return {};
}

export const GetLatestPrunedOffsetsRequest: MessageFns<GetLatestPrunedOffsetsRequest> = {
  encode(_: GetLatestPrunedOffsetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestPrunedOffsetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestPrunedOffsetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLatestPrunedOffsetsRequest {
    return {};
  },

  toJSON(_: GetLatestPrunedOffsetsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLatestPrunedOffsetsRequest>, I>>(base?: I): GetLatestPrunedOffsetsRequest {
    return GetLatestPrunedOffsetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLatestPrunedOffsetsRequest>, I>>(_: I): GetLatestPrunedOffsetsRequest {
    const message = createBaseGetLatestPrunedOffsetsRequest();
    return message;
  },
};

function createBaseGetLatestPrunedOffsetsResponse(): GetLatestPrunedOffsetsResponse {
  return { participantPrunedUpToInclusive: 0, allDivulgedContractsPrunedUpToInclusive: 0 };
}

export const GetLatestPrunedOffsetsResponse: MessageFns<GetLatestPrunedOffsetsResponse> = {
  encode(message: GetLatestPrunedOffsetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantPrunedUpToInclusive !== 0) {
      writer.uint32(8).int64(message.participantPrunedUpToInclusive);
    }
    if (message.allDivulgedContractsPrunedUpToInclusive !== 0) {
      writer.uint32(16).int64(message.allDivulgedContractsPrunedUpToInclusive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestPrunedOffsetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestPrunedOffsetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.participantPrunedUpToInclusive = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allDivulgedContractsPrunedUpToInclusive = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestPrunedOffsetsResponse {
    return {
      participantPrunedUpToInclusive: isSet(object.participantPrunedUpToInclusive)
        ? gt.Number(object.participantPrunedUpToInclusive)
        : 0,
      allDivulgedContractsPrunedUpToInclusive: isSet(object.allDivulgedContractsPrunedUpToInclusive)
        ? gt.Number(object.allDivulgedContractsPrunedUpToInclusive)
        : 0,
    };
  },

  toJSON(message: GetLatestPrunedOffsetsResponse): unknown {
    const obj: any = {};
    if (message.participantPrunedUpToInclusive !== 0) {
      obj.participantPrunedUpToInclusive = Math.round(message.participantPrunedUpToInclusive);
    }
    if (message.allDivulgedContractsPrunedUpToInclusive !== 0) {
      obj.allDivulgedContractsPrunedUpToInclusive = Math.round(message.allDivulgedContractsPrunedUpToInclusive);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLatestPrunedOffsetsResponse>, I>>(base?: I): GetLatestPrunedOffsetsResponse {
    return GetLatestPrunedOffsetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLatestPrunedOffsetsResponse>, I>>(
    object: I,
  ): GetLatestPrunedOffsetsResponse {
    const message = createBaseGetLatestPrunedOffsetsResponse();
    message.participantPrunedUpToInclusive = object.participantPrunedUpToInclusive ?? 0;
    message.allDivulgedContractsPrunedUpToInclusive = object.allDivulgedContractsPrunedUpToInclusive ?? 0;
    return message;
  },
};

/** Allows clients to get state from the ledger. */
export interface StateService {
  /**
   * Returns a stream of the snapshot of the active contracts and incomplete (un)assignments at a ledger offset.
   * If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken.
   * Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service.
   * Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
   */
  GetActiveContracts(request: GetActiveContractsRequest): Observable<GetActiveContractsResponse>;
  /** Get the list of connected synchronizers at the time of the query. */
  GetConnectedSynchronizers(request: GetConnectedSynchronizersRequest): Promise<GetConnectedSynchronizersResponse>;
  /**
   * Get the current ledger end.
   * Subscriptions started with the returned offset will serve events after this RPC was called.
   */
  GetLedgerEnd(request: GetLedgerEndRequest): Promise<GetLedgerEndResponse>;
  /** Get the latest successfully pruned ledger offsets */
  GetLatestPrunedOffsets(request: GetLatestPrunedOffsetsRequest): Promise<GetLatestPrunedOffsetsResponse>;
}

export const StateServiceServiceName = "com.daml.ledger.api.v2.StateService";
export class StateServiceClientImpl implements StateService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || StateServiceServiceName;
    this.rpc = rpc;
    this.GetActiveContracts = this.GetActiveContracts.bind(this);
    this.GetConnectedSynchronizers = this.GetConnectedSynchronizers.bind(this);
    this.GetLedgerEnd = this.GetLedgerEnd.bind(this);
    this.GetLatestPrunedOffsets = this.GetLatestPrunedOffsets.bind(this);
  }
  GetActiveContracts(request: GetActiveContractsRequest): Observable<GetActiveContractsResponse> {
    const data = GetActiveContractsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetActiveContracts", data);
    return result.pipe(map((data) => GetActiveContractsResponse.decode(new BinaryReader(data))));
  }

  GetConnectedSynchronizers(request: GetConnectedSynchronizersRequest): Promise<GetConnectedSynchronizersResponse> {
    const data = GetConnectedSynchronizersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetConnectedSynchronizers", data);
    return promise.then((data) => GetConnectedSynchronizersResponse.decode(new BinaryReader(data)));
  }

  GetLedgerEnd(request: GetLedgerEndRequest): Promise<GetLedgerEndResponse> {
    const data = GetLedgerEndRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLedgerEnd", data);
    return promise.then((data) => GetLedgerEndResponse.decode(new BinaryReader(data)));
  }

  GetLatestPrunedOffsets(request: GetLatestPrunedOffsetsRequest): Promise<GetLatestPrunedOffsetsResponse> {
    const data = GetLatestPrunedOffsetsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLatestPrunedOffsets", data);
    return promise.then((data) => GetLatestPrunedOffsetsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
