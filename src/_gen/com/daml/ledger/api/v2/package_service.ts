// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/package_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "com.daml.ledger.api.v2";

export enum PackageStatus {
  /** PACKAGE_STATUS_UNSPECIFIED - The server is not aware of such a package. */
  PACKAGE_STATUS_UNSPECIFIED = 0,
  /** PACKAGE_STATUS_REGISTERED - The server is able to execute Daml commands operating on this package. */
  PACKAGE_STATUS_REGISTERED = 1,
  UNRECOGNIZED = -1,
}

export function packageStatusFromJSON(object: any): PackageStatus {
  switch (object) {
    case 0:
    case "PACKAGE_STATUS_UNSPECIFIED":
      return PackageStatus.PACKAGE_STATUS_UNSPECIFIED;
    case 1:
    case "PACKAGE_STATUS_REGISTERED":
      return PackageStatus.PACKAGE_STATUS_REGISTERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PackageStatus.UNRECOGNIZED;
  }
}

export function packageStatusToJSON(object: PackageStatus): string {
  switch (object) {
    case PackageStatus.PACKAGE_STATUS_UNSPECIFIED:
      return "PACKAGE_STATUS_UNSPECIFIED";
    case PackageStatus.PACKAGE_STATUS_REGISTERED:
      return "PACKAGE_STATUS_REGISTERED";
    case PackageStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HashFunction {
  HASH_FUNCTION_SHA256 = 0,
  UNRECOGNIZED = -1,
}

export function hashFunctionFromJSON(object: any): HashFunction {
  switch (object) {
    case 0:
    case "HASH_FUNCTION_SHA256":
      return HashFunction.HASH_FUNCTION_SHA256;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HashFunction.UNRECOGNIZED;
  }
}

export function hashFunctionToJSON(object: HashFunction): string {
  switch (object) {
    case HashFunction.HASH_FUNCTION_SHA256:
      return "HASH_FUNCTION_SHA256";
    case HashFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ListPackagesResponse {
  /**
   * The IDs of all Daml-LF packages supported by the server.
   * Each element must be a valid PackageIdString (as described in ``value.proto``).
   * Required
   */
  packageIds: string[];
}

export interface GetPackageResponse {
  /**
   * The hash function we use to calculate the hash.
   * Required
   */
  hashFunction: HashFunction;
  /**
   * Contains a ``daml_lf`` ArchivePayload. See further details in ``daml_lf.proto``.
   * Required
   */
  archivePayload: Uint8Array;
  /**
   * The hash of the archive payload, can also used as a ``package_id``.
   * Must be a valid PackageIdString (as described in ``value.proto``).
   * Required
   */
  hash: string;
}

export interface GetPackageStatusResponse {
  /** The status of the package. */
  packageStatus: PackageStatus;
}

export interface ListPackagesRequest {
}

export interface GetPackageRequest {
  /**
   * The ID of the requested package.
   * Must be a valid PackageIdString (as described in ``value.proto``).
   * Required
   */
  packageId: string;
}

export interface GetPackageStatusRequest {
  /**
   * The ID of the requested package.
   * Must be a valid PackageIdString (as described in ``value.proto``).
   * Required
   */
  packageId: string;
}

function createBaseListPackagesResponse(): ListPackagesResponse {
  return { packageIds: [] };
}

export const ListPackagesResponse: MessageFns<ListPackagesResponse> = {
  encode(message: ListPackagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packageIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPackagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPackagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packageIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPackagesResponse {
    return { packageIds: gt.Array.isArray(object?.packageIds) ? object.packageIds.map((e: any) => gt.String(e)) : [] };
  },

  toJSON(message: ListPackagesResponse): unknown {
    const obj: any = {};
    if (message.packageIds?.length) {
      obj.packageIds = message.packageIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPackagesResponse>, I>>(base?: I): ListPackagesResponse {
    return ListPackagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPackagesResponse>, I>>(object: I): ListPackagesResponse {
    const message = createBaseListPackagesResponse();
    message.packageIds = object.packageIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPackageResponse(): GetPackageResponse {
  return { hashFunction: 0, archivePayload: new Uint8Array(0), hash: "" };
}

export const GetPackageResponse: MessageFns<GetPackageResponse> = {
  encode(message: GetPackageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashFunction !== 0) {
      writer.uint32(8).int32(message.hashFunction);
    }
    if (message.archivePayload.length !== 0) {
      writer.uint32(18).bytes(message.archivePayload);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPackageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPackageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hashFunction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.archivePayload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPackageResponse {
    return {
      hashFunction: isSet(object.hashFunction) ? hashFunctionFromJSON(object.hashFunction) : 0,
      archivePayload: isSet(object.archivePayload) ? bytesFromBase64(object.archivePayload) : new Uint8Array(0),
      hash: isSet(object.hash) ? gt.String(object.hash) : "",
    };
  },

  toJSON(message: GetPackageResponse): unknown {
    const obj: any = {};
    if (message.hashFunction !== 0) {
      obj.hashFunction = hashFunctionToJSON(message.hashFunction);
    }
    if (message.archivePayload.length !== 0) {
      obj.archivePayload = base64FromBytes(message.archivePayload);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPackageResponse>, I>>(base?: I): GetPackageResponse {
    return GetPackageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPackageResponse>, I>>(object: I): GetPackageResponse {
    const message = createBaseGetPackageResponse();
    message.hashFunction = object.hashFunction ?? 0;
    message.archivePayload = object.archivePayload ?? new Uint8Array(0);
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseGetPackageStatusResponse(): GetPackageStatusResponse {
  return { packageStatus: 0 };
}

export const GetPackageStatusResponse: MessageFns<GetPackageStatusResponse> = {
  encode(message: GetPackageStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageStatus !== 0) {
      writer.uint32(8).int32(message.packageStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPackageStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPackageStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.packageStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPackageStatusResponse {
    return { packageStatus: isSet(object.packageStatus) ? packageStatusFromJSON(object.packageStatus) : 0 };
  },

  toJSON(message: GetPackageStatusResponse): unknown {
    const obj: any = {};
    if (message.packageStatus !== 0) {
      obj.packageStatus = packageStatusToJSON(message.packageStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPackageStatusResponse>, I>>(base?: I): GetPackageStatusResponse {
    return GetPackageStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPackageStatusResponse>, I>>(object: I): GetPackageStatusResponse {
    const message = createBaseGetPackageStatusResponse();
    message.packageStatus = object.packageStatus ?? 0;
    return message;
  },
};

function createBaseListPackagesRequest(): ListPackagesRequest {
  return {};
}

export const ListPackagesRequest: MessageFns<ListPackagesRequest> = {
  encode(_: ListPackagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPackagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPackagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListPackagesRequest {
    return {};
  },

  toJSON(_: ListPackagesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPackagesRequest>, I>>(base?: I): ListPackagesRequest {
    return ListPackagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPackagesRequest>, I>>(_: I): ListPackagesRequest {
    const message = createBaseListPackagesRequest();
    return message;
  },
};

function createBaseGetPackageRequest(): GetPackageRequest {
  return { packageId: "" };
}

export const GetPackageRequest: MessageFns<GetPackageRequest> = {
  encode(message: GetPackageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageId !== "") {
      writer.uint32(10).string(message.packageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPackageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPackageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPackageRequest {
    return { packageId: isSet(object.packageId) ? gt.String(object.packageId) : "" };
  },

  toJSON(message: GetPackageRequest): unknown {
    const obj: any = {};
    if (message.packageId !== "") {
      obj.packageId = message.packageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPackageRequest>, I>>(base?: I): GetPackageRequest {
    return GetPackageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPackageRequest>, I>>(object: I): GetPackageRequest {
    const message = createBaseGetPackageRequest();
    message.packageId = object.packageId ?? "";
    return message;
  },
};

function createBaseGetPackageStatusRequest(): GetPackageStatusRequest {
  return { packageId: "" };
}

export const GetPackageStatusRequest: MessageFns<GetPackageStatusRequest> = {
  encode(message: GetPackageStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageId !== "") {
      writer.uint32(10).string(message.packageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPackageStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPackageStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPackageStatusRequest {
    return { packageId: isSet(object.packageId) ? gt.String(object.packageId) : "" };
  },

  toJSON(message: GetPackageStatusRequest): unknown {
    const obj: any = {};
    if (message.packageId !== "") {
      obj.packageId = message.packageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPackageStatusRequest>, I>>(base?: I): GetPackageStatusRequest {
    return GetPackageStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPackageStatusRequest>, I>>(object: I): GetPackageStatusRequest {
    const message = createBaseGetPackageStatusRequest();
    message.packageId = object.packageId ?? "";
    return message;
  },
};

/** Allows clients to query the Daml-LF packages that are supported by the server. */
export interface PackageService {
  /** Returns the identifiers of all supported packages. */
  ListPackages(request: ListPackagesRequest): Promise<ListPackagesResponse>;
  /** Returns the contents of a single package. */
  GetPackage(request: GetPackageRequest): Promise<GetPackageResponse>;
  /** Returns the status of a single package. */
  GetPackageStatus(request: GetPackageStatusRequest): Promise<GetPackageStatusResponse>;
}

export const PackageServiceServiceName = "com.daml.ledger.api.v2.PackageService";
export class PackageServiceClientImpl implements PackageService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PackageServiceServiceName;
    this.rpc = rpc;
    this.ListPackages = this.ListPackages.bind(this);
    this.GetPackage = this.GetPackage.bind(this);
    this.GetPackageStatus = this.GetPackageStatus.bind(this);
  }
  ListPackages(request: ListPackagesRequest): Promise<ListPackagesResponse> {
    const data = ListPackagesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPackages", data);
    return promise.then((data) => ListPackagesResponse.decode(new BinaryReader(data)));
  }

  GetPackage(request: GetPackageRequest): Promise<GetPackageResponse> {
    const data = GetPackageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPackage", data);
    return promise.then((data) => GetPackageResponse.decode(new BinaryReader(data)));
  }

  GetPackageStatus(request: GetPackageStatusRequest): Promise<GetPackageStatusResponse> {
    const data = GetPackageStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPackageStatus", data);
    return promise.then((data) => GetPackageStatusResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  const bin = gt.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(gt.String.fromCharCode(byte));
  });
  return gt.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
