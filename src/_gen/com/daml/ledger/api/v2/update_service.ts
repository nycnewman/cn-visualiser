// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/update_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { OffsetCheckpoint } from "./offset_checkpoint";
import { Reassignment } from "./reassignment";
import { TopologyTransaction } from "./topology_transaction";
import { Transaction, TransactionTree } from "./transaction";
import { TransactionFilter, TransactionFormat, UpdateFormat } from "./transaction_filter";

export const protobufPackage = "com.daml.ledger.api.v2";

export interface GetUpdatesRequest {
  /**
   * Beginning of the requested ledger section (non-negative integer).
   * The response will only contain transactions whose offset is strictly greater than this.
   * If zero, the stream will start from the beginning of the ledger.
   * If positive, the streaming will start after this absolute offset.
   * If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
   */
  beginExclusive: number;
  /**
   * End of the requested ledger section.
   * The response will only contain transactions whose offset is less than or equal to this.
   * Optional, if empty, the stream will not terminate.
   * If specified, the stream will terminate after this absolute offset (positive integer) is reached.
   */
  endInclusive?:
    | number
    | undefined;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Requesting parties with template filters.
   * Template filters must be empty for GetUpdateTrees requests.
   * Optional for backwards compatibility, if defined update_format must be unset
   */
  filter:
    | TransactionFilter
    | undefined;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
   * In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids
   * for record fields.
   * Optional for backwards compatibility, if defined update_format must be unset
   */
  verbose: boolean;
  /**
   * Must be unset for GetUpdateTrees request.
   * Optional for backwards compatibility for GetUpdates request: defaults to an UpdateFormat where:
   *
   * - include_transactions.event_format.filters_by_party = the filter.filters_by_party on this request
   * - include_transactions.event_format.filters_for_any_party = the filter.filters_for_any_party on this request
   * - include_transactions.event_format.verbose = the same flag specified on this request
   * - include_transactions.transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
   * - include_reassignments.filter = the same filter specified on this request
   * - include_reassignments.verbose = the same flag specified on this request
   * - include_topology_events.include_participant_authorization_events.parties = all the parties specified in filter
   */
  updateFormat: UpdateFormat | undefined;
}

export interface GetUpdatesResponse {
  transaction?: Transaction | undefined;
  reassignment?: Reassignment | undefined;
  offsetCheckpoint?: OffsetCheckpoint | undefined;
  topologyTransaction?: TopologyTransaction | undefined;
}

/** Provided for backwards compatibility, it will be removed in the Canton version 3.4.0. */
export interface GetUpdateTreesResponse {
  transactionTree?: TransactionTree | undefined;
  reassignment?: Reassignment | undefined;
  offsetCheckpoint?: OffsetCheckpoint | undefined;
}

/** Provided for backwards compatibility, it will be removed in the Canton version 3.4.0. */
export interface GetTransactionByOffsetRequest {
  /**
   * The offset of the transaction being looked up.
   * Must be a valid absolute offset (positive integer).
   * Required
   */
  offset: number;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * The parties whose events the client expects to see.
   * Events that are not visible for the parties in this collection will not be present in the response.
   * Each element must be a valid PartyIdString (as described in ``value.proto``).
   * Must be set for GetTransactionTreeByOffset request.
   * Optional for backwards compatibility for GetTransactionByOffset request: if defined transaction_format must be
   * unset (falling back to defaults).
   */
  requestingParties: string[];
  /**
   * Must be unset for GetTransactionTreeByOffset request.
   * Optional for GetTransactionByOffset request for backwards compatibility: defaults to a TransactionFormat, where:
   *
   * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
   * - event_format.filters_for_any_party is unset
   * - event_format.verbose = true
   * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
   */
  transactionFormat: TransactionFormat | undefined;
}

/** Provided for backwards compatibility, it will be removed in the Canton version 3.4.0. */
export interface GetTransactionByIdRequest {
  /**
   * The ID of a particular transaction.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  updateId: string;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * The parties whose events the client expects to see.
   * Events that are not visible for the parties in this collection will not be present in the response.
   * Each element must be a valid PartyIdString (as described in ``value.proto``).
   * Must be set for GetTransactionTreeById request.
   * Optional for backwards compatibility for GetTransactionById request: if defined transaction_format must be
   * unset (falling back to defaults).
   */
  requestingParties: string[];
  /**
   * Must be unset for GetTransactionTreeById request.
   * Optional for GetTransactionById request for backwards compatibility: defaults to a transaction_format, where:
   *
   * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
   * - event_format.filters_for_any_party is unset
   * - event_format.verbose = true
   * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
   */
  transactionFormat: TransactionFormat | undefined;
}

/** Provided for backwards compatibility, it will be removed in the Canton version 3.4.0. */
export interface GetTransactionTreeResponse {
  /** Required */
  transaction: TransactionTree | undefined;
}

/** Provided for backwards compatibility, it will be removed in the Canton version 3.4.0. */
export interface GetTransactionResponse {
  /** Required */
  transaction: Transaction | undefined;
}

export interface GetUpdateByOffsetRequest {
  /**
   * The offset of the update being looked up.
   * Must be a valid absolute offset (positive integer).
   * Required
   */
  offset: number;
  /**
   * The format for the update.
   * Required
   */
  updateFormat: UpdateFormat | undefined;
}

export interface GetUpdateByIdRequest {
  /**
   * The ID of a particular update.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  updateId: string;
  /**
   * The format for the update.
   * Required
   */
  updateFormat: UpdateFormat | undefined;
}

export interface GetUpdateResponse {
  transaction?: Transaction | undefined;
  reassignment?: Reassignment | undefined;
  topologyTransaction?: TopologyTransaction | undefined;
}

function createBaseGetUpdatesRequest(): GetUpdatesRequest {
  return { beginExclusive: 0, endInclusive: undefined, filter: undefined, verbose: false, updateFormat: undefined };
}

export const GetUpdatesRequest: MessageFns<GetUpdatesRequest> = {
  encode(message: GetUpdatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.beginExclusive !== 0) {
      writer.uint32(8).int64(message.beginExclusive);
    }
    if (message.endInclusive !== undefined) {
      writer.uint32(16).int64(message.endInclusive);
    }
    if (message.filter !== undefined) {
      TransactionFilter.encode(message.filter, writer.uint32(26).fork()).join();
    }
    if (message.verbose !== false) {
      writer.uint32(32).bool(message.verbose);
    }
    if (message.updateFormat !== undefined) {
      UpdateFormat.encode(message.updateFormat, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.beginExclusive = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endInclusive = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = TransactionFilter.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updateFormat = UpdateFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdatesRequest {
    return {
      beginExclusive: isSet(object.beginExclusive) ? gt.Number(object.beginExclusive) : 0,
      endInclusive: isSet(object.endInclusive) ? gt.Number(object.endInclusive) : undefined,
      filter: isSet(object.filter) ? TransactionFilter.fromJSON(object.filter) : undefined,
      verbose: isSet(object.verbose) ? gt.Boolean(object.verbose) : false,
      updateFormat: isSet(object.updateFormat) ? UpdateFormat.fromJSON(object.updateFormat) : undefined,
    };
  },

  toJSON(message: GetUpdatesRequest): unknown {
    const obj: any = {};
    if (message.beginExclusive !== 0) {
      obj.beginExclusive = Math.round(message.beginExclusive);
    }
    if (message.endInclusive !== undefined) {
      obj.endInclusive = Math.round(message.endInclusive);
    }
    if (message.filter !== undefined) {
      obj.filter = TransactionFilter.toJSON(message.filter);
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    if (message.updateFormat !== undefined) {
      obj.updateFormat = UpdateFormat.toJSON(message.updateFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdatesRequest>, I>>(base?: I): GetUpdatesRequest {
    return GetUpdatesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdatesRequest>, I>>(object: I): GetUpdatesRequest {
    const message = createBaseGetUpdatesRequest();
    message.beginExclusive = object.beginExclusive ?? 0;
    message.endInclusive = object.endInclusive ?? undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? TransactionFilter.fromPartial(object.filter)
      : undefined;
    message.verbose = object.verbose ?? false;
    message.updateFormat = (object.updateFormat !== undefined && object.updateFormat !== null)
      ? UpdateFormat.fromPartial(object.updateFormat)
      : undefined;
    return message;
  },
};

function createBaseGetUpdatesResponse(): GetUpdatesResponse {
  return {
    transaction: undefined,
    reassignment: undefined,
    offsetCheckpoint: undefined,
    topologyTransaction: undefined,
  };
}

export const GetUpdatesResponse: MessageFns<GetUpdatesResponse> = {
  encode(message: GetUpdatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    if (message.reassignment !== undefined) {
      Reassignment.encode(message.reassignment, writer.uint32(18).fork()).join();
    }
    if (message.offsetCheckpoint !== undefined) {
      OffsetCheckpoint.encode(message.offsetCheckpoint, writer.uint32(26).fork()).join();
    }
    if (message.topologyTransaction !== undefined) {
      TopologyTransaction.encode(message.topologyTransaction, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reassignment = Reassignment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.offsetCheckpoint = OffsetCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.topologyTransaction = TopologyTransaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdatesResponse {
    return {
      transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined,
      reassignment: isSet(object.reassignment) ? Reassignment.fromJSON(object.reassignment) : undefined,
      offsetCheckpoint: isSet(object.offsetCheckpoint) ? OffsetCheckpoint.fromJSON(object.offsetCheckpoint) : undefined,
      topologyTransaction: isSet(object.topologyTransaction)
        ? TopologyTransaction.fromJSON(object.topologyTransaction)
        : undefined,
    };
  },

  toJSON(message: GetUpdatesResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.reassignment !== undefined) {
      obj.reassignment = Reassignment.toJSON(message.reassignment);
    }
    if (message.offsetCheckpoint !== undefined) {
      obj.offsetCheckpoint = OffsetCheckpoint.toJSON(message.offsetCheckpoint);
    }
    if (message.topologyTransaction !== undefined) {
      obj.topologyTransaction = TopologyTransaction.toJSON(message.topologyTransaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdatesResponse>, I>>(base?: I): GetUpdatesResponse {
    return GetUpdatesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdatesResponse>, I>>(object: I): GetUpdatesResponse {
    const message = createBaseGetUpdatesResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    message.reassignment = (object.reassignment !== undefined && object.reassignment !== null)
      ? Reassignment.fromPartial(object.reassignment)
      : undefined;
    message.offsetCheckpoint = (object.offsetCheckpoint !== undefined && object.offsetCheckpoint !== null)
      ? OffsetCheckpoint.fromPartial(object.offsetCheckpoint)
      : undefined;
    message.topologyTransaction = (object.topologyTransaction !== undefined && object.topologyTransaction !== null)
      ? TopologyTransaction.fromPartial(object.topologyTransaction)
      : undefined;
    return message;
  },
};

function createBaseGetUpdateTreesResponse(): GetUpdateTreesResponse {
  return { transactionTree: undefined, reassignment: undefined, offsetCheckpoint: undefined };
}

export const GetUpdateTreesResponse: MessageFns<GetUpdateTreesResponse> = {
  encode(message: GetUpdateTreesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionTree !== undefined) {
      TransactionTree.encode(message.transactionTree, writer.uint32(10).fork()).join();
    }
    if (message.reassignment !== undefined) {
      Reassignment.encode(message.reassignment, writer.uint32(18).fork()).join();
    }
    if (message.offsetCheckpoint !== undefined) {
      OffsetCheckpoint.encode(message.offsetCheckpoint, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdateTreesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdateTreesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionTree = TransactionTree.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reassignment = Reassignment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.offsetCheckpoint = OffsetCheckpoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdateTreesResponse {
    return {
      transactionTree: isSet(object.transactionTree) ? TransactionTree.fromJSON(object.transactionTree) : undefined,
      reassignment: isSet(object.reassignment) ? Reassignment.fromJSON(object.reassignment) : undefined,
      offsetCheckpoint: isSet(object.offsetCheckpoint) ? OffsetCheckpoint.fromJSON(object.offsetCheckpoint) : undefined,
    };
  },

  toJSON(message: GetUpdateTreesResponse): unknown {
    const obj: any = {};
    if (message.transactionTree !== undefined) {
      obj.transactionTree = TransactionTree.toJSON(message.transactionTree);
    }
    if (message.reassignment !== undefined) {
      obj.reassignment = Reassignment.toJSON(message.reassignment);
    }
    if (message.offsetCheckpoint !== undefined) {
      obj.offsetCheckpoint = OffsetCheckpoint.toJSON(message.offsetCheckpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdateTreesResponse>, I>>(base?: I): GetUpdateTreesResponse {
    return GetUpdateTreesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdateTreesResponse>, I>>(object: I): GetUpdateTreesResponse {
    const message = createBaseGetUpdateTreesResponse();
    message.transactionTree = (object.transactionTree !== undefined && object.transactionTree !== null)
      ? TransactionTree.fromPartial(object.transactionTree)
      : undefined;
    message.reassignment = (object.reassignment !== undefined && object.reassignment !== null)
      ? Reassignment.fromPartial(object.reassignment)
      : undefined;
    message.offsetCheckpoint = (object.offsetCheckpoint !== undefined && object.offsetCheckpoint !== null)
      ? OffsetCheckpoint.fromPartial(object.offsetCheckpoint)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionByOffsetRequest(): GetTransactionByOffsetRequest {
  return { offset: 0, requestingParties: [], transactionFormat: undefined };
}

export const GetTransactionByOffsetRequest: MessageFns<GetTransactionByOffsetRequest> = {
  encode(message: GetTransactionByOffsetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int64(message.offset);
    }
    for (const v of message.requestingParties) {
      writer.uint32(18).string(v!);
    }
    if (message.transactionFormat !== undefined) {
      TransactionFormat.encode(message.transactionFormat, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionByOffsetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionByOffsetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestingParties.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionFormat = TransactionFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionByOffsetRequest {
    return {
      offset: isSet(object.offset) ? gt.Number(object.offset) : 0,
      requestingParties: gt.Array.isArray(object?.requestingParties)
        ? object.requestingParties.map((e: any) => gt.String(e))
        : [],
      transactionFormat: isSet(object.transactionFormat)
        ? TransactionFormat.fromJSON(object.transactionFormat)
        : undefined,
    };
  },

  toJSON(message: GetTransactionByOffsetRequest): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.requestingParties?.length) {
      obj.requestingParties = message.requestingParties;
    }
    if (message.transactionFormat !== undefined) {
      obj.transactionFormat = TransactionFormat.toJSON(message.transactionFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionByOffsetRequest>, I>>(base?: I): GetTransactionByOffsetRequest {
    return GetTransactionByOffsetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionByOffsetRequest>, I>>(
    object: I,
  ): GetTransactionByOffsetRequest {
    const message = createBaseGetTransactionByOffsetRequest();
    message.offset = object.offset ?? 0;
    message.requestingParties = object.requestingParties?.map((e) => e) || [];
    message.transactionFormat = (object.transactionFormat !== undefined && object.transactionFormat !== null)
      ? TransactionFormat.fromPartial(object.transactionFormat)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionByIdRequest(): GetTransactionByIdRequest {
  return { updateId: "", requestingParties: [], transactionFormat: undefined };
}

export const GetTransactionByIdRequest: MessageFns<GetTransactionByIdRequest> = {
  encode(message: GetTransactionByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    for (const v of message.requestingParties) {
      writer.uint32(18).string(v!);
    }
    if (message.transactionFormat !== undefined) {
      TransactionFormat.encode(message.transactionFormat, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestingParties.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionFormat = TransactionFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionByIdRequest {
    return {
      updateId: isSet(object.updateId) ? gt.String(object.updateId) : "",
      requestingParties: gt.Array.isArray(object?.requestingParties)
        ? object.requestingParties.map((e: any) => gt.String(e))
        : [],
      transactionFormat: isSet(object.transactionFormat)
        ? TransactionFormat.fromJSON(object.transactionFormat)
        : undefined,
    };
  },

  toJSON(message: GetTransactionByIdRequest): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.requestingParties?.length) {
      obj.requestingParties = message.requestingParties;
    }
    if (message.transactionFormat !== undefined) {
      obj.transactionFormat = TransactionFormat.toJSON(message.transactionFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionByIdRequest>, I>>(base?: I): GetTransactionByIdRequest {
    return GetTransactionByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionByIdRequest>, I>>(object: I): GetTransactionByIdRequest {
    const message = createBaseGetTransactionByIdRequest();
    message.updateId = object.updateId ?? "";
    message.requestingParties = object.requestingParties?.map((e) => e) || [];
    message.transactionFormat = (object.transactionFormat !== undefined && object.transactionFormat !== null)
      ? TransactionFormat.fromPartial(object.transactionFormat)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionTreeResponse(): GetTransactionTreeResponse {
  return { transaction: undefined };
}

export const GetTransactionTreeResponse: MessageFns<GetTransactionTreeResponse> = {
  encode(message: GetTransactionTreeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      TransactionTree.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionTreeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionTreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = TransactionTree.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionTreeResponse {
    return { transaction: isSet(object.transaction) ? TransactionTree.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetTransactionTreeResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = TransactionTree.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionTreeResponse>, I>>(base?: I): GetTransactionTreeResponse {
    return GetTransactionTreeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionTreeResponse>, I>>(object: I): GetTransactionTreeResponse {
    const message = createBaseGetTransactionTreeResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionTree.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseGetTransactionResponse(): GetTransactionResponse {
  return { transaction: undefined };
}

export const GetTransactionResponse: MessageFns<GetTransactionResponse> = {
  encode(message: GetTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionResponse {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetTransactionResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionResponse>, I>>(base?: I): GetTransactionResponse {
    return GetTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionResponse>, I>>(object: I): GetTransactionResponse {
    const message = createBaseGetTransactionResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseGetUpdateByOffsetRequest(): GetUpdateByOffsetRequest {
  return { offset: 0, updateFormat: undefined };
}

export const GetUpdateByOffsetRequest: MessageFns<GetUpdateByOffsetRequest> = {
  encode(message: GetUpdateByOffsetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int64(message.offset);
    }
    if (message.updateFormat !== undefined) {
      UpdateFormat.encode(message.updateFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdateByOffsetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdateByOffsetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateFormat = UpdateFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdateByOffsetRequest {
    return {
      offset: isSet(object.offset) ? gt.Number(object.offset) : 0,
      updateFormat: isSet(object.updateFormat) ? UpdateFormat.fromJSON(object.updateFormat) : undefined,
    };
  },

  toJSON(message: GetUpdateByOffsetRequest): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.updateFormat !== undefined) {
      obj.updateFormat = UpdateFormat.toJSON(message.updateFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdateByOffsetRequest>, I>>(base?: I): GetUpdateByOffsetRequest {
    return GetUpdateByOffsetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdateByOffsetRequest>, I>>(object: I): GetUpdateByOffsetRequest {
    const message = createBaseGetUpdateByOffsetRequest();
    message.offset = object.offset ?? 0;
    message.updateFormat = (object.updateFormat !== undefined && object.updateFormat !== null)
      ? UpdateFormat.fromPartial(object.updateFormat)
      : undefined;
    return message;
  },
};

function createBaseGetUpdateByIdRequest(): GetUpdateByIdRequest {
  return { updateId: "", updateFormat: undefined };
}

export const GetUpdateByIdRequest: MessageFns<GetUpdateByIdRequest> = {
  encode(message: GetUpdateByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.updateFormat !== undefined) {
      UpdateFormat.encode(message.updateFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdateByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdateByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateFormat = UpdateFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdateByIdRequest {
    return {
      updateId: isSet(object.updateId) ? gt.String(object.updateId) : "",
      updateFormat: isSet(object.updateFormat) ? UpdateFormat.fromJSON(object.updateFormat) : undefined,
    };
  },

  toJSON(message: GetUpdateByIdRequest): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.updateFormat !== undefined) {
      obj.updateFormat = UpdateFormat.toJSON(message.updateFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdateByIdRequest>, I>>(base?: I): GetUpdateByIdRequest {
    return GetUpdateByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdateByIdRequest>, I>>(object: I): GetUpdateByIdRequest {
    const message = createBaseGetUpdateByIdRequest();
    message.updateId = object.updateId ?? "";
    message.updateFormat = (object.updateFormat !== undefined && object.updateFormat !== null)
      ? UpdateFormat.fromPartial(object.updateFormat)
      : undefined;
    return message;
  },
};

function createBaseGetUpdateResponse(): GetUpdateResponse {
  return { transaction: undefined, reassignment: undefined, topologyTransaction: undefined };
}

export const GetUpdateResponse: MessageFns<GetUpdateResponse> = {
  encode(message: GetUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    if (message.reassignment !== undefined) {
      Reassignment.encode(message.reassignment, writer.uint32(18).fork()).join();
    }
    if (message.topologyTransaction !== undefined) {
      TopologyTransaction.encode(message.topologyTransaction, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reassignment = Reassignment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topologyTransaction = TopologyTransaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUpdateResponse {
    return {
      transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined,
      reassignment: isSet(object.reassignment) ? Reassignment.fromJSON(object.reassignment) : undefined,
      topologyTransaction: isSet(object.topologyTransaction)
        ? TopologyTransaction.fromJSON(object.topologyTransaction)
        : undefined,
    };
  },

  toJSON(message: GetUpdateResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.reassignment !== undefined) {
      obj.reassignment = Reassignment.toJSON(message.reassignment);
    }
    if (message.topologyTransaction !== undefined) {
      obj.topologyTransaction = TopologyTransaction.toJSON(message.topologyTransaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUpdateResponse>, I>>(base?: I): GetUpdateResponse {
    return GetUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUpdateResponse>, I>>(object: I): GetUpdateResponse {
    const message = createBaseGetUpdateResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    message.reassignment = (object.reassignment !== undefined && object.reassignment !== null)
      ? Reassignment.fromPartial(object.reassignment)
      : undefined;
    message.topologyTransaction = (object.topologyTransaction !== undefined && object.topologyTransaction !== null)
      ? TopologyTransaction.fromPartial(object.topologyTransaction)
      : undefined;
    return message;
  },
};

/**
 * Allows clients to read updates (transactions, (un)assignments, topology events) from the ledger.
 *
 * ``GetUpdates`` and ``GetUpdateTrees`` provide a comprehensive stream of updates/changes
 * which happened on the virtual shared ledger. These streams are indexed with ledger
 * offsets, which are strictly increasing.
 * The virtual shared ledger consist of changes happening on multiple synchronizers which are
 * connected to the serving participant. Each update belongs to one synchronizer, this is
 * provided in the result (the ``synchronizer_id`` field in ``Transaction`` and ``TransactionTree``
 * for transactions, the ``source`` field in ``UnassignedEvent`` and the ``target`` field in ``AssignedEvent``).
 * Consumers can rely on strong causal guarantees on the virtual shared ledger for a single
 * synchronizer: updates which have greater offsets are happened after than updates with smaller
 * offsets for the same synchronizer. Across different synchronizers this is not guaranteed.
 */
export interface UpdateService {
  /**
   * Read the ledger's filtered update stream for the specified contents and filters.
   * It returns the event types in accordance with the stream contents selected. Also the selection criteria
   * for individual events depends on the transaction shape chosen.
   *
   * - ACS delta: a requesting party must be a stakeholder of an event for it to be included.
   * - ledger effects: a requesting party must be a witness of an en event for it to be included.
   */
  GetUpdates(request: GetUpdatesRequest): Observable<GetUpdatesResponse>;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Read the ledger's complete transaction tree stream and related (un)assignments for a set of parties.
   * The stream will be filtered only by the parties as wildcard parties.
   * The template/interface filters describe the respective fields in the ``CreatedEvent`` results.
   */
  GetUpdateTrees(request: GetUpdatesRequest): Observable<GetUpdateTreesResponse>;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Lookup a transaction tree by its offset.
   * For looking up a transaction instead of a transaction tree, please see GetTransactionByEventId
   * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
   */
  GetTransactionTreeByOffset(request: GetTransactionByOffsetRequest): Promise<GetTransactionTreeResponse>;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Lookup a transaction tree by its ID.
   * For looking up a transaction instead of a transaction tree, please see GetTransactionById
   * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
   */
  GetTransactionTreeById(request: GetTransactionByIdRequest): Promise<GetTransactionTreeResponse>;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Lookup a transaction by its offset.
   * If there is no transaction with this offset, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
   * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
   */
  GetTransactionByOffset(request: GetTransactionByOffsetRequest): Promise<GetTransactionResponse>;
  /**
   * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
   * Lookup a transaction by its ID.
   * If there is no transaction with this id, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
   * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
   */
  GetTransactionById(request: GetTransactionByIdRequest): Promise<GetTransactionResponse>;
  /**
   * Lookup an update by its offset.
   * If there is no update with this offset, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
   */
  GetUpdateByOffset(request: GetUpdateByOffsetRequest): Promise<GetUpdateResponse>;
  /**
   * Lookup an update by its ID.
   * If there is no update with this ID, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
   */
  GetUpdateById(request: GetUpdateByIdRequest): Promise<GetUpdateResponse>;
}

export const UpdateServiceServiceName = "com.daml.ledger.api.v2.UpdateService";
export class UpdateServiceClientImpl implements UpdateService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UpdateServiceServiceName;
    this.rpc = rpc;
    this.GetUpdates = this.GetUpdates.bind(this);
    this.GetUpdateTrees = this.GetUpdateTrees.bind(this);
    this.GetTransactionTreeByOffset = this.GetTransactionTreeByOffset.bind(this);
    this.GetTransactionTreeById = this.GetTransactionTreeById.bind(this);
    this.GetTransactionByOffset = this.GetTransactionByOffset.bind(this);
    this.GetTransactionById = this.GetTransactionById.bind(this);
    this.GetUpdateByOffset = this.GetUpdateByOffset.bind(this);
    this.GetUpdateById = this.GetUpdateById.bind(this);
  }
  GetUpdates(request: GetUpdatesRequest): Observable<GetUpdatesResponse> {
    const data = GetUpdatesRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetUpdates", data);
    return result.pipe(map((data) => GetUpdatesResponse.decode(new BinaryReader(data))));
  }

  GetUpdateTrees(request: GetUpdatesRequest): Observable<GetUpdateTreesResponse> {
    const data = GetUpdatesRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetUpdateTrees", data);
    return result.pipe(map((data) => GetUpdateTreesResponse.decode(new BinaryReader(data))));
  }

  GetTransactionTreeByOffset(request: GetTransactionByOffsetRequest): Promise<GetTransactionTreeResponse> {
    const data = GetTransactionByOffsetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTransactionTreeByOffset", data);
    return promise.then((data) => GetTransactionTreeResponse.decode(new BinaryReader(data)));
  }

  GetTransactionTreeById(request: GetTransactionByIdRequest): Promise<GetTransactionTreeResponse> {
    const data = GetTransactionByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTransactionTreeById", data);
    return promise.then((data) => GetTransactionTreeResponse.decode(new BinaryReader(data)));
  }

  GetTransactionByOffset(request: GetTransactionByOffsetRequest): Promise<GetTransactionResponse> {
    const data = GetTransactionByOffsetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTransactionByOffset", data);
    return promise.then((data) => GetTransactionResponse.decode(new BinaryReader(data)));
  }

  GetTransactionById(request: GetTransactionByIdRequest): Promise<GetTransactionResponse> {
    const data = GetTransactionByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTransactionById", data);
    return promise.then((data) => GetTransactionResponse.decode(new BinaryReader(data)));
  }

  GetUpdateByOffset(request: GetUpdateByOffsetRequest): Promise<GetUpdateResponse> {
    const data = GetUpdateByOffsetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUpdateByOffset", data);
    return promise.then((data) => GetUpdateResponse.decode(new BinaryReader(data)));
  }

  GetUpdateById(request: GetUpdateByIdRequest): Promise<GetUpdateResponse> {
    const data = GetUpdateByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUpdateById", data);
    return promise.then((data) => GetUpdateResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
