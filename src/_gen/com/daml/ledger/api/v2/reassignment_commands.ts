// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/reassignment_commands.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "com.daml.ledger.api.v2";

export interface ReassignmentCommands {
  /**
   * Identifier of the on-ledger workflow that this command is a part of.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Optional
   */
  workflowId: string;
  /**
   * Uniquely identifies the participant user that issued the command.
   * Must be a valid UserIdString (as described in ``value.proto``).
   * Required unless authentication is used with a user token.
   * In that case, the token's user-id will be used for the request's user_id.
   */
  userId: string;
  /**
   * Uniquely identifies the command.
   * The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
   * The change ID can be used for matching the intended ledger changes with all their completions.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  commandId: string;
  /**
   * Party on whose behalf the command should be executed.
   * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
   * to act on behalf of the given party.
   * Must be a valid PartyIdString (as described in ``value.proto``).
   * Required
   */
  submitter: string;
  /**
   * A unique identifier to distinguish completions for different submissions with the same change ID.
   * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
   * with the same change ID.
   * Must be a valid LedgerString (as described in ``value.proto``).
   *
   * If omitted, the participant or the committer may set a value of their choice.
   * Optional
   */
  submissionId: string;
  /** Individual elements of this reassignment. Must be non-empty. */
  commands: ReassignmentCommand[];
}

export interface ReassignmentCommand {
  unassignCommand?: UnassignCommand | undefined;
  assignCommand?: AssignCommand | undefined;
}

/** Unassign a contract */
export interface UnassignCommand {
  /**
   * The ID of the contract the client wants to unassign.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  contractId: string;
  /**
   * The ID of the source synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  source: string;
  /**
   * The ID of the target synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  target: string;
}

/** Assign a contract */
export interface AssignCommand {
  /**
   * The ID from the unassigned event to be completed by this assignment.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  unassignId: string;
  /**
   * The ID of the source synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  source: string;
  /**
   * The ID of the target synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  target: string;
}

function createBaseReassignmentCommands(): ReassignmentCommands {
  return { workflowId: "", userId: "", commandId: "", submitter: "", submissionId: "", commands: [] };
}

export const ReassignmentCommands: MessageFns<ReassignmentCommands> = {
  encode(message: ReassignmentCommands, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.commandId !== "") {
      writer.uint32(26).string(message.commandId);
    }
    if (message.submitter !== "") {
      writer.uint32(34).string(message.submitter);
    }
    if (message.submissionId !== "") {
      writer.uint32(42).string(message.submissionId);
    }
    for (const v of message.commands) {
      ReassignmentCommand.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReassignmentCommands {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReassignmentCommands();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.submissionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.commands.push(ReassignmentCommand.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReassignmentCommands {
    return {
      workflowId: isSet(object.workflowId) ? gt.String(object.workflowId) : "",
      userId: isSet(object.userId) ? gt.String(object.userId) : "",
      commandId: isSet(object.commandId) ? gt.String(object.commandId) : "",
      submitter: isSet(object.submitter) ? gt.String(object.submitter) : "",
      submissionId: isSet(object.submissionId) ? gt.String(object.submissionId) : "",
      commands: gt.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => ReassignmentCommand.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReassignmentCommands): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.submissionId !== "") {
      obj.submissionId = message.submissionId;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => ReassignmentCommand.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReassignmentCommands>, I>>(base?: I): ReassignmentCommands {
    return ReassignmentCommands.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReassignmentCommands>, I>>(object: I): ReassignmentCommands {
    const message = createBaseReassignmentCommands();
    message.workflowId = object.workflowId ?? "";
    message.userId = object.userId ?? "";
    message.commandId = object.commandId ?? "";
    message.submitter = object.submitter ?? "";
    message.submissionId = object.submissionId ?? "";
    message.commands = object.commands?.map((e) => ReassignmentCommand.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReassignmentCommand(): ReassignmentCommand {
  return { unassignCommand: undefined, assignCommand: undefined };
}

export const ReassignmentCommand: MessageFns<ReassignmentCommand> = {
  encode(message: ReassignmentCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unassignCommand !== undefined) {
      UnassignCommand.encode(message.unassignCommand, writer.uint32(10).fork()).join();
    }
    if (message.assignCommand !== undefined) {
      AssignCommand.encode(message.assignCommand, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReassignmentCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReassignmentCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unassignCommand = UnassignCommand.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assignCommand = AssignCommand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReassignmentCommand {
    return {
      unassignCommand: isSet(object.unassignCommand) ? UnassignCommand.fromJSON(object.unassignCommand) : undefined,
      assignCommand: isSet(object.assignCommand) ? AssignCommand.fromJSON(object.assignCommand) : undefined,
    };
  },

  toJSON(message: ReassignmentCommand): unknown {
    const obj: any = {};
    if (message.unassignCommand !== undefined) {
      obj.unassignCommand = UnassignCommand.toJSON(message.unassignCommand);
    }
    if (message.assignCommand !== undefined) {
      obj.assignCommand = AssignCommand.toJSON(message.assignCommand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReassignmentCommand>, I>>(base?: I): ReassignmentCommand {
    return ReassignmentCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReassignmentCommand>, I>>(object: I): ReassignmentCommand {
    const message = createBaseReassignmentCommand();
    message.unassignCommand = (object.unassignCommand !== undefined && object.unassignCommand !== null)
      ? UnassignCommand.fromPartial(object.unassignCommand)
      : undefined;
    message.assignCommand = (object.assignCommand !== undefined && object.assignCommand !== null)
      ? AssignCommand.fromPartial(object.assignCommand)
      : undefined;
    return message;
  },
};

function createBaseUnassignCommand(): UnassignCommand {
  return { contractId: "", source: "", target: "" };
}

export const UnassignCommand: MessageFns<UnassignCommand> = {
  encode(message: UnassignCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractId !== "") {
      writer.uint32(10).string(message.contractId);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnassignCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnassignCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnassignCommand {
    return {
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      source: isSet(object.source) ? gt.String(object.source) : "",
      target: isSet(object.target) ? gt.String(object.target) : "",
    };
  },

  toJSON(message: UnassignCommand): unknown {
    const obj: any = {};
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnassignCommand>, I>>(base?: I): UnassignCommand {
    return UnassignCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnassignCommand>, I>>(object: I): UnassignCommand {
    const message = createBaseUnassignCommand();
    message.contractId = object.contractId ?? "";
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseAssignCommand(): AssignCommand {
  return { unassignId: "", source: "", target: "" };
}

export const AssignCommand: MessageFns<AssignCommand> = {
  encode(message: AssignCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unassignId !== "") {
      writer.uint32(10).string(message.unassignId);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unassignId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignCommand {
    return {
      unassignId: isSet(object.unassignId) ? gt.String(object.unassignId) : "",
      source: isSet(object.source) ? gt.String(object.source) : "",
      target: isSet(object.target) ? gt.String(object.target) : "",
    };
  },

  toJSON(message: AssignCommand): unknown {
    const obj: any = {};
    if (message.unassignId !== "") {
      obj.unassignId = message.unassignId;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignCommand>, I>>(base?: I): AssignCommand {
    return AssignCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignCommand>, I>>(object: I): AssignCommand {
    const message = createBaseAssignCommand();
    message.unassignId = object.unassignId ?? "";
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
