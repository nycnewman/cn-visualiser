// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/commands.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { Timestamp } from "../../../../../google/protobuf/timestamp";
import { Identifier, Record, Value } from "./value";

export const protobufPackage = "com.daml.ledger.api.v2";

/** A command can either create a new contract or exercise a choice on an existing contract. */
export interface Command {
  create?: CreateCommand | undefined;
  exercise?: ExerciseCommand | undefined;
  exerciseByKey?: ExerciseByKeyCommand | undefined;
  createAndExercise?: CreateAndExerciseCommand | undefined;
}

/** Create a new contract instance based on a template. */
export interface CreateCommand {
  /**
   * The template of contract the client wants to create.
   * Both package-name and package-id reference identifier formats for the template-id are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The arguments required for creating a contract from this template.
   * Required
   */
  createArguments: Record | undefined;
}

/** Exercise a choice on an existing contract. */
export interface ExerciseCommand {
  /**
   * The template of contract the client wants to exercise.
   * Both package-name and package-id reference identifier formats for the template-id are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The ID of the contract the client wants to exercise upon.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  contractId: string;
  /**
   * The name of the choice the client wants to exercise.
   * Must be a valid NameString (as described in ``value.proto``)
   * Required
   */
  choice: string;
  /**
   * The argument for this choice.
   * Required
   */
  choiceArgument: Value | undefined;
}

/** Exercise a choice on an existing contract specified by its key. */
export interface ExerciseByKeyCommand {
  /**
   * The template of contract the client wants to exercise.
   * Both package-name and package-id reference identifier formats for the template-id are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The key of the contract the client wants to exercise upon.
   * Required
   */
  contractKey:
    | Value
    | undefined;
  /**
   * The name of the choice the client wants to exercise.
   * Must be a valid NameString (as described in ``value.proto``)
   * Required
   */
  choice: string;
  /**
   * The argument for this choice.
   * Required
   */
  choiceArgument: Value | undefined;
}

/** Create a contract and exercise a choice on it in the same transaction. */
export interface CreateAndExerciseCommand {
  /**
   * The template of the contract the client wants to create.
   * Both package-name and package-id reference identifier formats for the template-id are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The arguments required for creating a contract from this template.
   * Required
   */
  createArguments:
    | Record
    | undefined;
  /**
   * The name of the choice the client wants to exercise.
   * Must be a valid NameString (as described in ``value.proto``).
   * Required
   */
  choice: string;
  /**
   * The argument for this choice.
   * Required
   */
  choiceArgument: Value | undefined;
}

/**
 * An additional contract that is used to resolve
 * contract & contract key lookups.
 */
export interface DisclosedContract {
  /**
   * The template id of the contract.
   * The identifier uses the package-id reference format.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The contract id
   * Required
   */
  contractId: string;
  /**
   * Opaque byte string containing the complete payload required by the Daml engine
   * to reconstruct a contract not known to the receiving participant.
   * Required
   */
  createdEventBlob: Uint8Array;
  /**
   * The ID of the synchronizer where the contract is currently assigned
   * Optional
   */
  synchronizerId: string;
}

/** A composite command that groups multiple commands together. */
export interface Commands {
  /**
   * Identifier of the on-ledger workflow that this command is a part of.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Optional
   */
  workflowId: string;
  /**
   * Uniquely identifies the participant user that issued the command.
   * Must be a valid UserIdString (as described in ``value.proto``).
   * Required unless authentication is used with a user token.
   * In that case, the token's user-id will be used for the request's user_id.
   */
  userId: string;
  /**
   * Uniquely identifies the command.
   * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
   * where act_as is interpreted as a set of party names.
   * The change ID can be used for matching the intended ledger changes with all their completions.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  commandId: string;
  /**
   * Individual elements of this atomic command. Must be non-empty.
   * Required
   */
  commands: Command[];
  /**
   * Specifies the length of the deduplication period.
   * It is interpreted relative to the local clock at some point during the submission's processing.
   * Must be non-negative. Must not exceed the maximum deduplication time.
   */
  deduplicationDuration?:
    | Duration
    | undefined;
  /**
   * Specifies the start of the deduplication period by a completion stream offset (exclusive).
   * Must be a valid absolute offset (positive integer) or participant begin (zero).
   */
  deduplicationOffset?:
    | number
    | undefined;
  /**
   * Lower bound for the ledger time assigned to the resulting transaction.
   * Note: The ledger time of a transaction is assigned as part of command interpretation.
   * Use this property if you expect that command interpretation will take a considerate amount of time, such that by
   * the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
   * Must not be set at the same time as min_ledger_time_rel.
   * Optional
   */
  minLedgerTimeAbs:
    | Date
    | undefined;
  /**
   * Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server.
   * Must not be set at the same time as min_ledger_time_abs.
   * Optional
   */
  minLedgerTimeRel:
    | Duration
    | undefined;
  /**
   * Set of parties on whose behalf the command should be executed.
   * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
   * to act on behalf of each of the given parties.
   * Each element must be a valid PartyIdString (as described in ``value.proto``).
   * Required, must be non-empty.
   */
  actAs: string[];
  /**
   * Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
   * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
   * Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
   * node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
   * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
   * rules for fetch operations.
   * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
   * to read contract data on behalf of each of the given parties.
   * Optional
   */
  readAs: string[];
  /**
   * A unique identifier to distinguish completions for different submissions with the same change ID.
   * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
   * with the same change ID.
   * Must be a valid LedgerString (as described in ``value.proto``).
   *
   * If omitted, the participant or the committer may set a value of their choice.
   * Optional
   */
  submissionId: string;
  /**
   * Additional contracts used to resolve contract & contract key lookups.
   * Optional
   */
  disclosedContracts: DisclosedContract[];
  /**
   * Must be a valid synchronizer id
   * Optional
   */
  synchronizerId: string;
  /**
   * The package-id selection preference of the client for resolving
   * package names and interface instances in command submission and interpretation
   */
  packageIdSelectionPreference: string[];
  /**
   * Fetches the contract keys into the caches to speed up the command processing.
   * Should only contain contract keys that are expected to be resolved during interpretation of the commands.
   * Keys of disclosed contracts do not need prefetching.
   *
   * Optional
   */
  prefetchContractKeys: PrefetchContractKey[];
}

/** Preload contracts */
export interface PrefetchContractKey {
  /**
   * The template of contract the client wants to prefetch.
   * Both package-name and package-id reference identifier formats for the template-id are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The key of the contract the client wants to prefetch.
   * Required
   */
  contractKey: Value | undefined;
}

function createBaseCommand(): Command {
  return { create: undefined, exercise: undefined, exerciseByKey: undefined, createAndExercise: undefined };
}

export const Command: MessageFns<Command> = {
  encode(message: Command, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create !== undefined) {
      CreateCommand.encode(message.create, writer.uint32(10).fork()).join();
    }
    if (message.exercise !== undefined) {
      ExerciseCommand.encode(message.exercise, writer.uint32(18).fork()).join();
    }
    if (message.exerciseByKey !== undefined) {
      ExerciseByKeyCommand.encode(message.exerciseByKey, writer.uint32(34).fork()).join();
    }
    if (message.createAndExercise !== undefined) {
      CreateAndExerciseCommand.encode(message.createAndExercise, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Command {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.create = CreateCommand.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exercise = ExerciseCommand.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exerciseByKey = ExerciseByKeyCommand.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createAndExercise = CreateAndExerciseCommand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      create: isSet(object.create) ? CreateCommand.fromJSON(object.create) : undefined,
      exercise: isSet(object.exercise) ? ExerciseCommand.fromJSON(object.exercise) : undefined,
      exerciseByKey: isSet(object.exerciseByKey) ? ExerciseByKeyCommand.fromJSON(object.exerciseByKey) : undefined,
      createAndExercise: isSet(object.createAndExercise)
        ? CreateAndExerciseCommand.fromJSON(object.createAndExercise)
        : undefined,
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.create !== undefined) {
      obj.create = CreateCommand.toJSON(message.create);
    }
    if (message.exercise !== undefined) {
      obj.exercise = ExerciseCommand.toJSON(message.exercise);
    }
    if (message.exerciseByKey !== undefined) {
      obj.exerciseByKey = ExerciseByKeyCommand.toJSON(message.exerciseByKey);
    }
    if (message.createAndExercise !== undefined) {
      obj.createAndExercise = CreateAndExerciseCommand.toJSON(message.createAndExercise);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Command>, I>>(base?: I): Command {
    return Command.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Command>, I>>(object: I): Command {
    const message = createBaseCommand();
    message.create = (object.create !== undefined && object.create !== null)
      ? CreateCommand.fromPartial(object.create)
      : undefined;
    message.exercise = (object.exercise !== undefined && object.exercise !== null)
      ? ExerciseCommand.fromPartial(object.exercise)
      : undefined;
    message.exerciseByKey = (object.exerciseByKey !== undefined && object.exerciseByKey !== null)
      ? ExerciseByKeyCommand.fromPartial(object.exerciseByKey)
      : undefined;
    message.createAndExercise = (object.createAndExercise !== undefined && object.createAndExercise !== null)
      ? CreateAndExerciseCommand.fromPartial(object.createAndExercise)
      : undefined;
    return message;
  },
};

function createBaseCreateCommand(): CreateCommand {
  return { templateId: undefined, createArguments: undefined };
}

export const CreateCommand: MessageFns<CreateCommand> = {
  encode(message: CreateCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.createArguments !== undefined) {
      Record.encode(message.createArguments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createArguments = Record.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCommand {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      createArguments: isSet(object.createArguments) ? Record.fromJSON(object.createArguments) : undefined,
    };
  },

  toJSON(message: CreateCommand): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.createArguments !== undefined) {
      obj.createArguments = Record.toJSON(message.createArguments);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCommand>, I>>(base?: I): CreateCommand {
    return CreateCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCommand>, I>>(object: I): CreateCommand {
    const message = createBaseCreateCommand();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.createArguments = (object.createArguments !== undefined && object.createArguments !== null)
      ? Record.fromPartial(object.createArguments)
      : undefined;
    return message;
  },
};

function createBaseExerciseCommand(): ExerciseCommand {
  return { templateId: undefined, contractId: "", choice: "", choiceArgument: undefined };
}

export const ExerciseCommand: MessageFns<ExerciseCommand> = {
  encode(message: ExerciseCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.choice !== "") {
      writer.uint32(26).string(message.choice);
    }
    if (message.choiceArgument !== undefined) {
      Value.encode(message.choiceArgument, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExerciseCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.choice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.choiceArgument = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseCommand {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      choice: isSet(object.choice) ? gt.String(object.choice) : "",
      choiceArgument: isSet(object.choiceArgument) ? Value.fromJSON(object.choiceArgument) : undefined,
    };
  },

  toJSON(message: ExerciseCommand): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.choice !== "") {
      obj.choice = message.choice;
    }
    if (message.choiceArgument !== undefined) {
      obj.choiceArgument = Value.toJSON(message.choiceArgument);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseCommand>, I>>(base?: I): ExerciseCommand {
    return ExerciseCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseCommand>, I>>(object: I): ExerciseCommand {
    const message = createBaseExerciseCommand();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.contractId = object.contractId ?? "";
    message.choice = object.choice ?? "";
    message.choiceArgument = (object.choiceArgument !== undefined && object.choiceArgument !== null)
      ? Value.fromPartial(object.choiceArgument)
      : undefined;
    return message;
  },
};

function createBaseExerciseByKeyCommand(): ExerciseByKeyCommand {
  return { templateId: undefined, contractKey: undefined, choice: "", choiceArgument: undefined };
}

export const ExerciseByKeyCommand: MessageFns<ExerciseByKeyCommand> = {
  encode(message: ExerciseByKeyCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.contractKey !== undefined) {
      Value.encode(message.contractKey, writer.uint32(18).fork()).join();
    }
    if (message.choice !== "") {
      writer.uint32(26).string(message.choice);
    }
    if (message.choiceArgument !== undefined) {
      Value.encode(message.choiceArgument, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExerciseByKeyCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseByKeyCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractKey = Value.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.choice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.choiceArgument = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseByKeyCommand {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      contractKey: isSet(object.contractKey) ? Value.fromJSON(object.contractKey) : undefined,
      choice: isSet(object.choice) ? gt.String(object.choice) : "",
      choiceArgument: isSet(object.choiceArgument) ? Value.fromJSON(object.choiceArgument) : undefined,
    };
  },

  toJSON(message: ExerciseByKeyCommand): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.contractKey !== undefined) {
      obj.contractKey = Value.toJSON(message.contractKey);
    }
    if (message.choice !== "") {
      obj.choice = message.choice;
    }
    if (message.choiceArgument !== undefined) {
      obj.choiceArgument = Value.toJSON(message.choiceArgument);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseByKeyCommand>, I>>(base?: I): ExerciseByKeyCommand {
    return ExerciseByKeyCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseByKeyCommand>, I>>(object: I): ExerciseByKeyCommand {
    const message = createBaseExerciseByKeyCommand();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.contractKey = (object.contractKey !== undefined && object.contractKey !== null)
      ? Value.fromPartial(object.contractKey)
      : undefined;
    message.choice = object.choice ?? "";
    message.choiceArgument = (object.choiceArgument !== undefined && object.choiceArgument !== null)
      ? Value.fromPartial(object.choiceArgument)
      : undefined;
    return message;
  },
};

function createBaseCreateAndExerciseCommand(): CreateAndExerciseCommand {
  return { templateId: undefined, createArguments: undefined, choice: "", choiceArgument: undefined };
}

export const CreateAndExerciseCommand: MessageFns<CreateAndExerciseCommand> = {
  encode(message: CreateAndExerciseCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.createArguments !== undefined) {
      Record.encode(message.createArguments, writer.uint32(18).fork()).join();
    }
    if (message.choice !== "") {
      writer.uint32(26).string(message.choice);
    }
    if (message.choiceArgument !== undefined) {
      Value.encode(message.choiceArgument, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAndExerciseCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAndExerciseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createArguments = Record.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.choice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.choiceArgument = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAndExerciseCommand {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      createArguments: isSet(object.createArguments) ? Record.fromJSON(object.createArguments) : undefined,
      choice: isSet(object.choice) ? gt.String(object.choice) : "",
      choiceArgument: isSet(object.choiceArgument) ? Value.fromJSON(object.choiceArgument) : undefined,
    };
  },

  toJSON(message: CreateAndExerciseCommand): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.createArguments !== undefined) {
      obj.createArguments = Record.toJSON(message.createArguments);
    }
    if (message.choice !== "") {
      obj.choice = message.choice;
    }
    if (message.choiceArgument !== undefined) {
      obj.choiceArgument = Value.toJSON(message.choiceArgument);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAndExerciseCommand>, I>>(base?: I): CreateAndExerciseCommand {
    return CreateAndExerciseCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAndExerciseCommand>, I>>(object: I): CreateAndExerciseCommand {
    const message = createBaseCreateAndExerciseCommand();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.createArguments = (object.createArguments !== undefined && object.createArguments !== null)
      ? Record.fromPartial(object.createArguments)
      : undefined;
    message.choice = object.choice ?? "";
    message.choiceArgument = (object.choiceArgument !== undefined && object.choiceArgument !== null)
      ? Value.fromPartial(object.choiceArgument)
      : undefined;
    return message;
  },
};

function createBaseDisclosedContract(): DisclosedContract {
  return { templateId: undefined, contractId: "", createdEventBlob: new Uint8Array(0), synchronizerId: "" };
}

export const DisclosedContract: MessageFns<DisclosedContract> = {
  encode(message: DisclosedContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.createdEventBlob.length !== 0) {
      writer.uint32(26).bytes(message.createdEventBlob);
    }
    if (message.synchronizerId !== "") {
      writer.uint32(34).string(message.synchronizerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisclosedContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisclosedContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdEventBlob = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisclosedContract {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      createdEventBlob: isSet(object.createdEventBlob) ? bytesFromBase64(object.createdEventBlob) : new Uint8Array(0),
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
    };
  },

  toJSON(message: DisclosedContract): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.createdEventBlob.length !== 0) {
      obj.createdEventBlob = base64FromBytes(message.createdEventBlob);
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisclosedContract>, I>>(base?: I): DisclosedContract {
    return DisclosedContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisclosedContract>, I>>(object: I): DisclosedContract {
    const message = createBaseDisclosedContract();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.contractId = object.contractId ?? "";
    message.createdEventBlob = object.createdEventBlob ?? new Uint8Array(0);
    message.synchronizerId = object.synchronizerId ?? "";
    return message;
  },
};

function createBaseCommands(): Commands {
  return {
    workflowId: "",
    userId: "",
    commandId: "",
    commands: [],
    deduplicationDuration: undefined,
    deduplicationOffset: undefined,
    minLedgerTimeAbs: undefined,
    minLedgerTimeRel: undefined,
    actAs: [],
    readAs: [],
    submissionId: "",
    disclosedContracts: [],
    synchronizerId: "",
    packageIdSelectionPreference: [],
    prefetchContractKeys: [],
  };
}

export const Commands: MessageFns<Commands> = {
  encode(message: Commands, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.commandId !== "") {
      writer.uint32(26).string(message.commandId);
    }
    for (const v of message.commands) {
      Command.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.deduplicationDuration !== undefined) {
      Duration.encode(message.deduplicationDuration, writer.uint32(42).fork()).join();
    }
    if (message.deduplicationOffset !== undefined) {
      writer.uint32(48).int64(message.deduplicationOffset);
    }
    if (message.minLedgerTimeAbs !== undefined) {
      Timestamp.encode(toTimestamp(message.minLedgerTimeAbs), writer.uint32(58).fork()).join();
    }
    if (message.minLedgerTimeRel !== undefined) {
      Duration.encode(message.minLedgerTimeRel, writer.uint32(66).fork()).join();
    }
    for (const v of message.actAs) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.readAs) {
      writer.uint32(82).string(v!);
    }
    if (message.submissionId !== "") {
      writer.uint32(90).string(message.submissionId);
    }
    for (const v of message.disclosedContracts) {
      DisclosedContract.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.synchronizerId !== "") {
      writer.uint32(106).string(message.synchronizerId);
    }
    for (const v of message.packageIdSelectionPreference) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.prefetchContractKeys) {
      PrefetchContractKey.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Commands {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommands();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commands.push(Command.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deduplicationDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deduplicationOffset = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.minLedgerTimeAbs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minLedgerTimeRel = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.actAs.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.readAs.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.submissionId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.disclosedContracts.push(DisclosedContract.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.packageIdSelectionPreference.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.prefetchContractKeys.push(PrefetchContractKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Commands {
    return {
      workflowId: isSet(object.workflowId) ? gt.String(object.workflowId) : "",
      userId: isSet(object.userId) ? gt.String(object.userId) : "",
      commandId: isSet(object.commandId) ? gt.String(object.commandId) : "",
      commands: gt.Array.isArray(object?.commands) ? object.commands.map((e: any) => Command.fromJSON(e)) : [],
      deduplicationDuration: isSet(object.deduplicationDuration)
        ? Duration.fromJSON(object.deduplicationDuration)
        : undefined,
      deduplicationOffset: isSet(object.deduplicationOffset) ? gt.Number(object.deduplicationOffset) : undefined,
      minLedgerTimeAbs: isSet(object.minLedgerTimeAbs) ? fromJsonTimestamp(object.minLedgerTimeAbs) : undefined,
      minLedgerTimeRel: isSet(object.minLedgerTimeRel) ? Duration.fromJSON(object.minLedgerTimeRel) : undefined,
      actAs: gt.Array.isArray(object?.actAs) ? object.actAs.map((e: any) => gt.String(e)) : [],
      readAs: gt.Array.isArray(object?.readAs) ? object.readAs.map((e: any) => gt.String(e)) : [],
      submissionId: isSet(object.submissionId) ? gt.String(object.submissionId) : "",
      disclosedContracts: gt.Array.isArray(object?.disclosedContracts)
        ? object.disclosedContracts.map((e: any) => DisclosedContract.fromJSON(e))
        : [],
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      packageIdSelectionPreference: gt.Array.isArray(object?.packageIdSelectionPreference)
        ? object.packageIdSelectionPreference.map((e: any) => gt.String(e))
        : [],
      prefetchContractKeys: gt.Array.isArray(object?.prefetchContractKeys)
        ? object.prefetchContractKeys.map((e: any) => PrefetchContractKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Commands): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => Command.toJSON(e));
    }
    if (message.deduplicationDuration !== undefined) {
      obj.deduplicationDuration = Duration.toJSON(message.deduplicationDuration);
    }
    if (message.deduplicationOffset !== undefined) {
      obj.deduplicationOffset = Math.round(message.deduplicationOffset);
    }
    if (message.minLedgerTimeAbs !== undefined) {
      obj.minLedgerTimeAbs = message.minLedgerTimeAbs.toISOString();
    }
    if (message.minLedgerTimeRel !== undefined) {
      obj.minLedgerTimeRel = Duration.toJSON(message.minLedgerTimeRel);
    }
    if (message.actAs?.length) {
      obj.actAs = message.actAs;
    }
    if (message.readAs?.length) {
      obj.readAs = message.readAs;
    }
    if (message.submissionId !== "") {
      obj.submissionId = message.submissionId;
    }
    if (message.disclosedContracts?.length) {
      obj.disclosedContracts = message.disclosedContracts.map((e) => DisclosedContract.toJSON(e));
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.packageIdSelectionPreference?.length) {
      obj.packageIdSelectionPreference = message.packageIdSelectionPreference;
    }
    if (message.prefetchContractKeys?.length) {
      obj.prefetchContractKeys = message.prefetchContractKeys.map((e) => PrefetchContractKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Commands>, I>>(base?: I): Commands {
    return Commands.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Commands>, I>>(object: I): Commands {
    const message = createBaseCommands();
    message.workflowId = object.workflowId ?? "";
    message.userId = object.userId ?? "";
    message.commandId = object.commandId ?? "";
    message.commands = object.commands?.map((e) => Command.fromPartial(e)) || [];
    message.deduplicationDuration =
      (object.deduplicationDuration !== undefined && object.deduplicationDuration !== null)
        ? Duration.fromPartial(object.deduplicationDuration)
        : undefined;
    message.deduplicationOffset = object.deduplicationOffset ?? undefined;
    message.minLedgerTimeAbs = object.minLedgerTimeAbs ?? undefined;
    message.minLedgerTimeRel = (object.minLedgerTimeRel !== undefined && object.minLedgerTimeRel !== null)
      ? Duration.fromPartial(object.minLedgerTimeRel)
      : undefined;
    message.actAs = object.actAs?.map((e) => e) || [];
    message.readAs = object.readAs?.map((e) => e) || [];
    message.submissionId = object.submissionId ?? "";
    message.disclosedContracts = object.disclosedContracts?.map((e) => DisclosedContract.fromPartial(e)) || [];
    message.synchronizerId = object.synchronizerId ?? "";
    message.packageIdSelectionPreference = object.packageIdSelectionPreference?.map((e) => e) || [];
    message.prefetchContractKeys = object.prefetchContractKeys?.map((e) => PrefetchContractKey.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrefetchContractKey(): PrefetchContractKey {
  return { templateId: undefined, contractKey: undefined };
}

export const PrefetchContractKey: MessageFns<PrefetchContractKey> = {
  encode(message: PrefetchContractKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.contractKey !== undefined) {
      Value.encode(message.contractKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefetchContractKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefetchContractKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractKey = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefetchContractKey {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      contractKey: isSet(object.contractKey) ? Value.fromJSON(object.contractKey) : undefined,
    };
  },

  toJSON(message: PrefetchContractKey): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.contractKey !== undefined) {
      obj.contractKey = Value.toJSON(message.contractKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrefetchContractKey>, I>>(base?: I): PrefetchContractKey {
    return PrefetchContractKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrefetchContractKey>, I>>(object: I): PrefetchContractKey {
    const message = createBasePrefetchContractKey();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.contractKey = (object.contractKey !== undefined && object.contractKey !== null)
      ? Value.fromPartial(object.contractKey)
      : undefined;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  const bin = gt.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(gt.String.fromCharCode(byte));
  });
  return gt.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new gt.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof gt.Date) {
    return o;
  } else if (typeof o === "string") {
    return new gt.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
