// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/transaction_filter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Identifier } from "./value";

export const protobufPackage = "com.daml.ledger.api.v2";

/**
 * Event shape for Transactions.
 * Shapes are exclusive and only one of them can be defined in queries.
 */
export enum TransactionShape {
  /** TRANSACTION_SHAPE_UNSPECIFIED - Following official proto3 convention, not intended for actual use. */
  TRANSACTION_SHAPE_UNSPECIFIED = 0,
  /**
   * TRANSACTION_SHAPE_ACS_DELTA - Transaction shape that is sufficient to maintain an accurate ACS view.
   * The field witness_parties in events are populated as stakeholders, transaction filter will apply accordingly.
   * This translates to create and archive events.
   */
  TRANSACTION_SHAPE_ACS_DELTA = 1,
  /**
   * TRANSACTION_SHAPE_LEDGER_EFFECTS - Transaction shape that allows maintaining an ACS and also conveys detailed information about
   * all exercises.
   * The field witness_parties in events are populated as cumulative informees, transaction filter will apply accordingly.
   * This translates to create, consuming exercise and non-consuming exercise.
   */
  TRANSACTION_SHAPE_LEDGER_EFFECTS = 2,
  UNRECOGNIZED = -1,
}

export function transactionShapeFromJSON(object: any): TransactionShape {
  switch (object) {
    case 0:
    case "TRANSACTION_SHAPE_UNSPECIFIED":
      return TransactionShape.TRANSACTION_SHAPE_UNSPECIFIED;
    case 1:
    case "TRANSACTION_SHAPE_ACS_DELTA":
      return TransactionShape.TRANSACTION_SHAPE_ACS_DELTA;
    case 2:
    case "TRANSACTION_SHAPE_LEDGER_EFFECTS":
      return TransactionShape.TRANSACTION_SHAPE_LEDGER_EFFECTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionShape.UNRECOGNIZED;
  }
}

export function transactionShapeToJSON(object: TransactionShape): string {
  switch (object) {
    case TransactionShape.TRANSACTION_SHAPE_UNSPECIFIED:
      return "TRANSACTION_SHAPE_UNSPECIFIED";
    case TransactionShape.TRANSACTION_SHAPE_ACS_DELTA:
      return "TRANSACTION_SHAPE_ACS_DELTA";
    case TransactionShape.TRANSACTION_SHAPE_LEDGER_EFFECTS:
      return "TRANSACTION_SHAPE_LEDGER_EFFECTS";
    case TransactionShape.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The union of a set of template filters, interface filters, or a wildcard. */
export interface Filters {
  /**
   * Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
   * template or wildcard filter means additional events that will match the query.
   * The impact of include_interface_view and include_created_event_blob fields in the filters will
   * also be accumulated.
   * At least one cumulative filter MUST be specified.
   * A template or an interface SHOULD NOT appear twice in the accumulative field.
   * A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
   * Optional
   */
  cumulative: CumulativeFilter[];
}

/**
 * A filter that matches all contracts that are either an instance of one of
 * the ``template_filters`` or that match one of the ``interface_filters``.
 */
export interface CumulativeFilter {
  /**
   * A wildcard filter that matches all templates
   * Optional
   */
  wildcardFilter?:
    | WildcardFilter
    | undefined;
  /**
   * Include an ``InterfaceView`` for every ``InterfaceFilter`` matching a contract.
   * The ``InterfaceFilter`` instances MUST each use a unique ``interface_id``.
   * Optional
   */
  interfaceFilter?:
    | InterfaceFilter
    | undefined;
  /**
   * A template for which the data will be included in the
   * ``create_arguments`` of a matching ``CreatedEvent``.
   * If a contract is simultaneously selected by a template filter and one or more interface filters,
   * the corresponding ``include_created_event_blob`` are consolidated using an OR operation.
   * Optional
   */
  templateFilter?: TemplateFilter | undefined;
}

/** This filter matches all templates. */
export interface WildcardFilter {
  /**
   * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
   * Use this to access the contract create event payload in your API client
   * for submitting it as a disclosed contract with future commands.
   * Optional
   */
  includeCreatedEventBlob: boolean;
}

/** This filter matches contracts that implement a specific interface. */
export interface InterfaceFilter {
  /**
   * The interface that a matching contract must implement.
   * The ``interface_id`` needs to be valid: corresponding interface should be defined in
   * one of the available packages at the time of the query.
   * Both package-name and package-id reference formats for the identifier are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  interfaceId:
    | Identifier
    | undefined;
  /**
   * Whether to include the interface view on the contract in the returned ``CreatedEvent``.
   * Use this to access contract data in a uniform manner in your API client.
   * Optional
   */
  includeInterfaceView: boolean;
  /**
   * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
   * Use this to access the contract create event payload in your API client
   * for submitting it as a disclosed contract with future commands.
   * Optional
   */
  includeCreatedEventBlob: boolean;
}

/** This filter matches contracts of a specific template. */
export interface TemplateFilter {
  /**
   * A template for which the payload should be included in the response.
   * The ``template_id`` needs to be valid: corresponding template should be defined in
   * one of the available packages at the time of the query.
   * Both package-name and package-id reference formats for the identifier are supported.
   * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
   * Use this to access the contract event payload in your API client
   * for submitting it as a disclosed contract with future commands.
   * Optional
   */
  includeCreatedEventBlob: boolean;
}

/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 * Used both for filtering create and archive events as well as for filtering transaction trees.
 */
export interface TransactionFilter {
  /**
   * Each key must be a valid PartyIdString (as described in ``value.proto``).
   * The interpretation of the filter depends on the transaction-shape being filtered:
   *
   * 1. For **transaction trees** (used in GetUpdateTreesResponse for backwards compatibility) all party keys used as
   *    wildcard filters, and all subtrees whose root has one of the listed parties as an informee are returned.
   *    If there are ``CumulativeFilter``s, those will control returned ``CreatedEvent`` fields where applicable, but will
   *    not be used for template/interface filtering.
   * 2. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
   *    the listed parties and match the per-party filter.
   * 3. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
   *    stakeholders include at least one of the listed parties and match the per-party filter.
   *
   * Required
   */
  filtersByParty: { [key: string]: Filters };
  /**
   * Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
   * with the per-party filter as described above.
   */
  filtersForAnyParty: Filters | undefined;
}

export interface TransactionFilter_FiltersByPartyEntry {
  key: string;
  value: Filters | undefined;
}

/**
 * A format for events which defines both which events should be included
 * and what data should be computed and included for them.
 *
 * Note that some of the filtering behavior depends on the `TransactionShape`,
 * which is expected to be specified alongside usages of `EventFormat`.
 */
export interface EventFormat {
  /**
   * Each key must be a valid PartyIdString (as described in ``value.proto``).
   * The interpretation of the filter depends on the transaction-shape being filtered:
   *
   * 1. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
   *    the listed parties and match the per-party filter.
   * 2. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
   *    stakeholders include at least one of the listed parties and match the per-party filter.
   *
   * Optional
   */
  filtersByParty: { [key: string]: Filters };
  /**
   * Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
   * with the per-party filter as described above.
   * Optional
   */
  filtersForAnyParty:
    | Filters
    | undefined;
  /**
   * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
   * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
   * Optional
   */
  verbose: boolean;
}

export interface EventFormat_FiltersByPartyEntry {
  key: string;
  value: Filters | undefined;
}

/**
 * A format that specifies what events to include in Daml transactions
 * and what data to compute and include for them.
 */
export interface TransactionFormat {
  /** Required */
  eventFormat:
    | EventFormat
    | undefined;
  /**
   * What transaction shape to use for interpreting the filters of the event format.
   * Required
   */
  transactionShape: TransactionShape;
}

/** A format specifying which topology transactions to include and how to render them. */
export interface TopologyFormat {
  /**
   * Include participant authorization topology events in streams.
   * Optional, if unset no participant authorization topology events are emitted in the stream.
   */
  includeParticipantAuthorizationEvents: ParticipantAuthorizationTopologyFormat | undefined;
}

/** A format specifying which participant authorization topology transactions to include and how to render them. */
export interface ParticipantAuthorizationTopologyFormat {
  /**
   * List of parties for which the topology transactions should be sent.
   * Empty means: for all parties.
   */
  parties: string[];
}

/** A format specifying what updates to include and how to render them. */
export interface UpdateFormat {
  /**
   * Include Daml transactions in streams.
   * Optional, if unset, no transactions are emitted in the stream.
   */
  includeTransactions:
    | TransactionFormat
    | undefined;
  /**
   * Include (un)assignments in the stream.
   * The events in the result take the shape TRANSACTION_SHAPE_ACS_DELTA.
   * Optional, if unset, no (un)assignments are emitted in the stream.
   */
  includeReassignments:
    | EventFormat
    | undefined;
  /**
   * Include topology events in streams.
   * Optional, if unset no topology events are emitted in the stream.
   */
  includeTopologyEvents: TopologyFormat | undefined;
}

function createBaseFilters(): Filters {
  return { cumulative: [] };
}

export const Filters: MessageFns<Filters> = {
  encode(message: Filters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cumulative) {
      CumulativeFilter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cumulative.push(CumulativeFilter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filters {
    return {
      cumulative: gt.Array.isArray(object?.cumulative)
        ? object.cumulative.map((e: any) => CumulativeFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Filters): unknown {
    const obj: any = {};
    if (message.cumulative?.length) {
      obj.cumulative = message.cumulative.map((e) => CumulativeFilter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filters>, I>>(base?: I): Filters {
    return Filters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filters>, I>>(object: I): Filters {
    const message = createBaseFilters();
    message.cumulative = object.cumulative?.map((e) => CumulativeFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCumulativeFilter(): CumulativeFilter {
  return { wildcardFilter: undefined, interfaceFilter: undefined, templateFilter: undefined };
}

export const CumulativeFilter: MessageFns<CumulativeFilter> = {
  encode(message: CumulativeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wildcardFilter !== undefined) {
      WildcardFilter.encode(message.wildcardFilter, writer.uint32(10).fork()).join();
    }
    if (message.interfaceFilter !== undefined) {
      InterfaceFilter.encode(message.interfaceFilter, writer.uint32(18).fork()).join();
    }
    if (message.templateFilter !== undefined) {
      TemplateFilter.encode(message.templateFilter, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CumulativeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCumulativeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wildcardFilter = WildcardFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interfaceFilter = InterfaceFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.templateFilter = TemplateFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CumulativeFilter {
    return {
      wildcardFilter: isSet(object.wildcardFilter) ? WildcardFilter.fromJSON(object.wildcardFilter) : undefined,
      interfaceFilter: isSet(object.interfaceFilter) ? InterfaceFilter.fromJSON(object.interfaceFilter) : undefined,
      templateFilter: isSet(object.templateFilter) ? TemplateFilter.fromJSON(object.templateFilter) : undefined,
    };
  },

  toJSON(message: CumulativeFilter): unknown {
    const obj: any = {};
    if (message.wildcardFilter !== undefined) {
      obj.wildcardFilter = WildcardFilter.toJSON(message.wildcardFilter);
    }
    if (message.interfaceFilter !== undefined) {
      obj.interfaceFilter = InterfaceFilter.toJSON(message.interfaceFilter);
    }
    if (message.templateFilter !== undefined) {
      obj.templateFilter = TemplateFilter.toJSON(message.templateFilter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CumulativeFilter>, I>>(base?: I): CumulativeFilter {
    return CumulativeFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CumulativeFilter>, I>>(object: I): CumulativeFilter {
    const message = createBaseCumulativeFilter();
    message.wildcardFilter = (object.wildcardFilter !== undefined && object.wildcardFilter !== null)
      ? WildcardFilter.fromPartial(object.wildcardFilter)
      : undefined;
    message.interfaceFilter = (object.interfaceFilter !== undefined && object.interfaceFilter !== null)
      ? InterfaceFilter.fromPartial(object.interfaceFilter)
      : undefined;
    message.templateFilter = (object.templateFilter !== undefined && object.templateFilter !== null)
      ? TemplateFilter.fromPartial(object.templateFilter)
      : undefined;
    return message;
  },
};

function createBaseWildcardFilter(): WildcardFilter {
  return { includeCreatedEventBlob: false };
}

export const WildcardFilter: MessageFns<WildcardFilter> = {
  encode(message: WildcardFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeCreatedEventBlob !== false) {
      writer.uint32(8).bool(message.includeCreatedEventBlob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WildcardFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWildcardFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeCreatedEventBlob = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WildcardFilter {
    return {
      includeCreatedEventBlob: isSet(object.includeCreatedEventBlob)
        ? gt.Boolean(object.includeCreatedEventBlob)
        : false,
    };
  },

  toJSON(message: WildcardFilter): unknown {
    const obj: any = {};
    if (message.includeCreatedEventBlob !== false) {
      obj.includeCreatedEventBlob = message.includeCreatedEventBlob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WildcardFilter>, I>>(base?: I): WildcardFilter {
    return WildcardFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WildcardFilter>, I>>(object: I): WildcardFilter {
    const message = createBaseWildcardFilter();
    message.includeCreatedEventBlob = object.includeCreatedEventBlob ?? false;
    return message;
  },
};

function createBaseInterfaceFilter(): InterfaceFilter {
  return { interfaceId: undefined, includeInterfaceView: false, includeCreatedEventBlob: false };
}

export const InterfaceFilter: MessageFns<InterfaceFilter> = {
  encode(message: InterfaceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interfaceId !== undefined) {
      Identifier.encode(message.interfaceId, writer.uint32(10).fork()).join();
    }
    if (message.includeInterfaceView !== false) {
      writer.uint32(16).bool(message.includeInterfaceView);
    }
    if (message.includeCreatedEventBlob !== false) {
      writer.uint32(24).bool(message.includeCreatedEventBlob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterfaceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterfaceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interfaceId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeInterfaceView = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeCreatedEventBlob = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterfaceFilter {
    return {
      interfaceId: isSet(object.interfaceId) ? Identifier.fromJSON(object.interfaceId) : undefined,
      includeInterfaceView: isSet(object.includeInterfaceView) ? gt.Boolean(object.includeInterfaceView) : false,
      includeCreatedEventBlob: isSet(object.includeCreatedEventBlob)
        ? gt.Boolean(object.includeCreatedEventBlob)
        : false,
    };
  },

  toJSON(message: InterfaceFilter): unknown {
    const obj: any = {};
    if (message.interfaceId !== undefined) {
      obj.interfaceId = Identifier.toJSON(message.interfaceId);
    }
    if (message.includeInterfaceView !== false) {
      obj.includeInterfaceView = message.includeInterfaceView;
    }
    if (message.includeCreatedEventBlob !== false) {
      obj.includeCreatedEventBlob = message.includeCreatedEventBlob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InterfaceFilter>, I>>(base?: I): InterfaceFilter {
    return InterfaceFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InterfaceFilter>, I>>(object: I): InterfaceFilter {
    const message = createBaseInterfaceFilter();
    message.interfaceId = (object.interfaceId !== undefined && object.interfaceId !== null)
      ? Identifier.fromPartial(object.interfaceId)
      : undefined;
    message.includeInterfaceView = object.includeInterfaceView ?? false;
    message.includeCreatedEventBlob = object.includeCreatedEventBlob ?? false;
    return message;
  },
};

function createBaseTemplateFilter(): TemplateFilter {
  return { templateId: undefined, includeCreatedEventBlob: false };
}

export const TemplateFilter: MessageFns<TemplateFilter> = {
  encode(message: TemplateFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(10).fork()).join();
    }
    if (message.includeCreatedEventBlob !== false) {
      writer.uint32(16).bool(message.includeCreatedEventBlob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TemplateFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTemplateFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeCreatedEventBlob = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TemplateFilter {
    return {
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      includeCreatedEventBlob: isSet(object.includeCreatedEventBlob)
        ? gt.Boolean(object.includeCreatedEventBlob)
        : false,
    };
  },

  toJSON(message: TemplateFilter): unknown {
    const obj: any = {};
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.includeCreatedEventBlob !== false) {
      obj.includeCreatedEventBlob = message.includeCreatedEventBlob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TemplateFilter>, I>>(base?: I): TemplateFilter {
    return TemplateFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TemplateFilter>, I>>(object: I): TemplateFilter {
    const message = createBaseTemplateFilter();
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.includeCreatedEventBlob = object.includeCreatedEventBlob ?? false;
    return message;
  },
};

function createBaseTransactionFilter(): TransactionFilter {
  return { filtersByParty: {}, filtersForAnyParty: undefined };
}

export const TransactionFilter: MessageFns<TransactionFilter> = {
  encode(message: TransactionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.filtersByParty).forEach(([key, value]) => {
      TransactionFilter_FiltersByPartyEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.filtersForAnyParty !== undefined) {
      Filters.encode(message.filtersForAnyParty, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = TransactionFilter_FiltersByPartyEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.filtersByParty[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filtersForAnyParty = Filters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFilter {
    return {
      filtersByParty: isObject(object.filtersByParty)
        ? Object.entries(object.filtersByParty).reduce<{ [key: string]: Filters }>((acc, [key, value]) => {
          acc[key] = Filters.fromJSON(value);
          return acc;
        }, {})
        : {},
      filtersForAnyParty: isSet(object.filtersForAnyParty) ? Filters.fromJSON(object.filtersForAnyParty) : undefined,
    };
  },

  toJSON(message: TransactionFilter): unknown {
    const obj: any = {};
    if (message.filtersByParty) {
      const entries = Object.entries(message.filtersByParty);
      if (entries.length > 0) {
        obj.filtersByParty = {};
        entries.forEach(([k, v]) => {
          obj.filtersByParty[k] = Filters.toJSON(v);
        });
      }
    }
    if (message.filtersForAnyParty !== undefined) {
      obj.filtersForAnyParty = Filters.toJSON(message.filtersForAnyParty);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionFilter>, I>>(base?: I): TransactionFilter {
    return TransactionFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionFilter>, I>>(object: I): TransactionFilter {
    const message = createBaseTransactionFilter();
    message.filtersByParty = Object.entries(object.filtersByParty ?? {}).reduce<{ [key: string]: Filters }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Filters.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.filtersForAnyParty = (object.filtersForAnyParty !== undefined && object.filtersForAnyParty !== null)
      ? Filters.fromPartial(object.filtersForAnyParty)
      : undefined;
    return message;
  },
};

function createBaseTransactionFilter_FiltersByPartyEntry(): TransactionFilter_FiltersByPartyEntry {
  return { key: "", value: undefined };
}

export const TransactionFilter_FiltersByPartyEntry: MessageFns<TransactionFilter_FiltersByPartyEntry> = {
  encode(message: TransactionFilter_FiltersByPartyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Filters.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionFilter_FiltersByPartyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFilter_FiltersByPartyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Filters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFilter_FiltersByPartyEntry {
    return {
      key: isSet(object.key) ? gt.String(object.key) : "",
      value: isSet(object.value) ? Filters.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TransactionFilter_FiltersByPartyEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Filters.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionFilter_FiltersByPartyEntry>, I>>(
    base?: I,
  ): TransactionFilter_FiltersByPartyEntry {
    return TransactionFilter_FiltersByPartyEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionFilter_FiltersByPartyEntry>, I>>(
    object: I,
  ): TransactionFilter_FiltersByPartyEntry {
    const message = createBaseTransactionFilter_FiltersByPartyEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Filters.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEventFormat(): EventFormat {
  return { filtersByParty: {}, filtersForAnyParty: undefined, verbose: false };
}

export const EventFormat: MessageFns<EventFormat> = {
  encode(message: EventFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.filtersByParty).forEach(([key, value]) => {
      EventFormat_FiltersByPartyEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.filtersForAnyParty !== undefined) {
      Filters.encode(message.filtersForAnyParty, writer.uint32(18).fork()).join();
    }
    if (message.verbose !== false) {
      writer.uint32(24).bool(message.verbose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = EventFormat_FiltersByPartyEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.filtersByParty[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filtersForAnyParty = Filters.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFormat {
    return {
      filtersByParty: isObject(object.filtersByParty)
        ? Object.entries(object.filtersByParty).reduce<{ [key: string]: Filters }>((acc, [key, value]) => {
          acc[key] = Filters.fromJSON(value);
          return acc;
        }, {})
        : {},
      filtersForAnyParty: isSet(object.filtersForAnyParty) ? Filters.fromJSON(object.filtersForAnyParty) : undefined,
      verbose: isSet(object.verbose) ? gt.Boolean(object.verbose) : false,
    };
  },

  toJSON(message: EventFormat): unknown {
    const obj: any = {};
    if (message.filtersByParty) {
      const entries = Object.entries(message.filtersByParty);
      if (entries.length > 0) {
        obj.filtersByParty = {};
        entries.forEach(([k, v]) => {
          obj.filtersByParty[k] = Filters.toJSON(v);
        });
      }
    }
    if (message.filtersForAnyParty !== undefined) {
      obj.filtersForAnyParty = Filters.toJSON(message.filtersForAnyParty);
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFormat>, I>>(base?: I): EventFormat {
    return EventFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFormat>, I>>(object: I): EventFormat {
    const message = createBaseEventFormat();
    message.filtersByParty = Object.entries(object.filtersByParty ?? {}).reduce<{ [key: string]: Filters }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Filters.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.filtersForAnyParty = (object.filtersForAnyParty !== undefined && object.filtersForAnyParty !== null)
      ? Filters.fromPartial(object.filtersForAnyParty)
      : undefined;
    message.verbose = object.verbose ?? false;
    return message;
  },
};

function createBaseEventFormat_FiltersByPartyEntry(): EventFormat_FiltersByPartyEntry {
  return { key: "", value: undefined };
}

export const EventFormat_FiltersByPartyEntry: MessageFns<EventFormat_FiltersByPartyEntry> = {
  encode(message: EventFormat_FiltersByPartyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Filters.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFormat_FiltersByPartyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFormat_FiltersByPartyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Filters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFormat_FiltersByPartyEntry {
    return {
      key: isSet(object.key) ? gt.String(object.key) : "",
      value: isSet(object.value) ? Filters.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EventFormat_FiltersByPartyEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Filters.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFormat_FiltersByPartyEntry>, I>>(base?: I): EventFormat_FiltersByPartyEntry {
    return EventFormat_FiltersByPartyEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFormat_FiltersByPartyEntry>, I>>(
    object: I,
  ): EventFormat_FiltersByPartyEntry {
    const message = createBaseEventFormat_FiltersByPartyEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Filters.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTransactionFormat(): TransactionFormat {
  return { eventFormat: undefined, transactionShape: 0 };
}

export const TransactionFormat: MessageFns<TransactionFormat> = {
  encode(message: TransactionFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventFormat !== undefined) {
      EventFormat.encode(message.eventFormat, writer.uint32(10).fork()).join();
    }
    if (message.transactionShape !== 0) {
      writer.uint32(16).int32(message.transactionShape);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventFormat = EventFormat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionShape = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFormat {
    return {
      eventFormat: isSet(object.eventFormat) ? EventFormat.fromJSON(object.eventFormat) : undefined,
      transactionShape: isSet(object.transactionShape) ? transactionShapeFromJSON(object.transactionShape) : 0,
    };
  },

  toJSON(message: TransactionFormat): unknown {
    const obj: any = {};
    if (message.eventFormat !== undefined) {
      obj.eventFormat = EventFormat.toJSON(message.eventFormat);
    }
    if (message.transactionShape !== 0) {
      obj.transactionShape = transactionShapeToJSON(message.transactionShape);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionFormat>, I>>(base?: I): TransactionFormat {
    return TransactionFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionFormat>, I>>(object: I): TransactionFormat {
    const message = createBaseTransactionFormat();
    message.eventFormat = (object.eventFormat !== undefined && object.eventFormat !== null)
      ? EventFormat.fromPartial(object.eventFormat)
      : undefined;
    message.transactionShape = object.transactionShape ?? 0;
    return message;
  },
};

function createBaseTopologyFormat(): TopologyFormat {
  return { includeParticipantAuthorizationEvents: undefined };
}

export const TopologyFormat: MessageFns<TopologyFormat> = {
  encode(message: TopologyFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeParticipantAuthorizationEvents !== undefined) {
      ParticipantAuthorizationTopologyFormat.encode(
        message.includeParticipantAuthorizationEvents,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopologyFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopologyFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.includeParticipantAuthorizationEvents = ParticipantAuthorizationTopologyFormat.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopologyFormat {
    return {
      includeParticipantAuthorizationEvents: isSet(object.includeParticipantAuthorizationEvents)
        ? ParticipantAuthorizationTopologyFormat.fromJSON(object.includeParticipantAuthorizationEvents)
        : undefined,
    };
  },

  toJSON(message: TopologyFormat): unknown {
    const obj: any = {};
    if (message.includeParticipantAuthorizationEvents !== undefined) {
      obj.includeParticipantAuthorizationEvents = ParticipantAuthorizationTopologyFormat.toJSON(
        message.includeParticipantAuthorizationEvents,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopologyFormat>, I>>(base?: I): TopologyFormat {
    return TopologyFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopologyFormat>, I>>(object: I): TopologyFormat {
    const message = createBaseTopologyFormat();
    message.includeParticipantAuthorizationEvents =
      (object.includeParticipantAuthorizationEvents !== undefined &&
          object.includeParticipantAuthorizationEvents !== null)
        ? ParticipantAuthorizationTopologyFormat.fromPartial(object.includeParticipantAuthorizationEvents)
        : undefined;
    return message;
  },
};

function createBaseParticipantAuthorizationTopologyFormat(): ParticipantAuthorizationTopologyFormat {
  return { parties: [] };
}

export const ParticipantAuthorizationTopologyFormat: MessageFns<ParticipantAuthorizationTopologyFormat> = {
  encode(message: ParticipantAuthorizationTopologyFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parties) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParticipantAuthorizationTopologyFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantAuthorizationTopologyFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parties.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipantAuthorizationTopologyFormat {
    return { parties: gt.Array.isArray(object?.parties) ? object.parties.map((e: any) => gt.String(e)) : [] };
  },

  toJSON(message: ParticipantAuthorizationTopologyFormat): unknown {
    const obj: any = {};
    if (message.parties?.length) {
      obj.parties = message.parties;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParticipantAuthorizationTopologyFormat>, I>>(
    base?: I,
  ): ParticipantAuthorizationTopologyFormat {
    return ParticipantAuthorizationTopologyFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParticipantAuthorizationTopologyFormat>, I>>(
    object: I,
  ): ParticipantAuthorizationTopologyFormat {
    const message = createBaseParticipantAuthorizationTopologyFormat();
    message.parties = object.parties?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateFormat(): UpdateFormat {
  return { includeTransactions: undefined, includeReassignments: undefined, includeTopologyEvents: undefined };
}

export const UpdateFormat: MessageFns<UpdateFormat> = {
  encode(message: UpdateFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeTransactions !== undefined) {
      TransactionFormat.encode(message.includeTransactions, writer.uint32(10).fork()).join();
    }
    if (message.includeReassignments !== undefined) {
      EventFormat.encode(message.includeReassignments, writer.uint32(18).fork()).join();
    }
    if (message.includeTopologyEvents !== undefined) {
      TopologyFormat.encode(message.includeTopologyEvents, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.includeTransactions = TransactionFormat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.includeReassignments = EventFormat.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.includeTopologyEvents = TopologyFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFormat {
    return {
      includeTransactions: isSet(object.includeTransactions)
        ? TransactionFormat.fromJSON(object.includeTransactions)
        : undefined,
      includeReassignments: isSet(object.includeReassignments)
        ? EventFormat.fromJSON(object.includeReassignments)
        : undefined,
      includeTopologyEvents: isSet(object.includeTopologyEvents)
        ? TopologyFormat.fromJSON(object.includeTopologyEvents)
        : undefined,
    };
  },

  toJSON(message: UpdateFormat): unknown {
    const obj: any = {};
    if (message.includeTransactions !== undefined) {
      obj.includeTransactions = TransactionFormat.toJSON(message.includeTransactions);
    }
    if (message.includeReassignments !== undefined) {
      obj.includeReassignments = EventFormat.toJSON(message.includeReassignments);
    }
    if (message.includeTopologyEvents !== undefined) {
      obj.includeTopologyEvents = TopologyFormat.toJSON(message.includeTopologyEvents);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFormat>, I>>(base?: I): UpdateFormat {
    return UpdateFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFormat>, I>>(object: I): UpdateFormat {
    const message = createBaseUpdateFormat();
    message.includeTransactions = (object.includeTransactions !== undefined && object.includeTransactions !== null)
      ? TransactionFormat.fromPartial(object.includeTransactions)
      : undefined;
    message.includeReassignments = (object.includeReassignments !== undefined && object.includeReassignments !== null)
      ? EventFormat.fromPartial(object.includeReassignments)
      : undefined;
    message.includeTopologyEvents =
      (object.includeTopologyEvents !== undefined && object.includeTopologyEvents !== null)
        ? TopologyFormat.fromPartial(object.includeTopologyEvents)
        : undefined;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
