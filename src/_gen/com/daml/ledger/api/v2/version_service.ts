// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/version_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration";
import { ExperimentalFeatures } from "./experimental_features";

export const protobufPackage = "com.daml.ledger.api.v2";

export interface GetLedgerApiVersionRequest {
}

export interface GetLedgerApiVersionResponse {
  /** The version of the ledger API. */
  version: string;
  /**
   * The features supported by this Ledger API endpoint.
   *
   * Daml applications CAN use the feature descriptor on top of
   * version constraints on the Ledger API version to determine
   * whether a given Ledger API endpoint supports the features
   * required to run the application.
   *
   * See the feature descriptions themselves for the relation between
   * Ledger API versions and feature presence.
   */
  features: FeaturesDescriptor | undefined;
}

export interface FeaturesDescriptor {
  /**
   * Features under development or features that are used
   * for ledger implementation testing purposes only.
   *
   * Daml applications SHOULD not depend on these in production.
   */
  experimental:
    | ExperimentalFeatures
    | undefined;
  /**
   * If set, then the Ledger API server supports user management.
   * It is recommended that clients query this field to gracefully adjust their behavior for
   * ledgers that do not support user management.
   */
  userManagement:
    | UserManagementFeature
    | undefined;
  /**
   * If set, then the Ledger API server supports party management configurability.
   * It is recommended that clients query this field to gracefully adjust their behavior to
   * maximum party page size.
   */
  partyManagement:
    | PartyManagementFeature
    | undefined;
  /** It contains the timeouts related to the periodic offset checkpoint emission */
  offsetCheckpoint: OffsetCheckpointFeature | undefined;
}

export interface UserManagementFeature {
  /** Whether the Ledger API server provides the user management service. */
  supported: boolean;
  /**
   * The maximum number of rights that can be assigned to a single user.
   * Servers MUST support at least 100 rights per user.
   * A value of 0 means that the server enforces no rights per user limit.
   */
  maxRightsPerUser: number;
  /**
   * The maximum number of users the server can return in a single response (page).
   * Servers MUST support at least a 100 users per page.
   * A value of 0 means that the server enforces no page size limit.
   */
  maxUsersPageSize: number;
}

export interface PartyManagementFeature {
  /** The maximum number of parties the server can return in a single response (page). */
  maxPartiesPageSize: number;
}

export interface OffsetCheckpointFeature {
  /** The maximum delay to emmit a new OffsetCheckpoint if it exists */
  maxOffsetCheckpointEmissionDelay: Duration | undefined;
}

function createBaseGetLedgerApiVersionRequest(): GetLedgerApiVersionRequest {
  return {};
}

export const GetLedgerApiVersionRequest: MessageFns<GetLedgerApiVersionRequest> = {
  encode(_: GetLedgerApiVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerApiVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerApiVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLedgerApiVersionRequest {
    return {};
  },

  toJSON(_: GetLedgerApiVersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerApiVersionRequest>, I>>(base?: I): GetLedgerApiVersionRequest {
    return GetLedgerApiVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerApiVersionRequest>, I>>(_: I): GetLedgerApiVersionRequest {
    const message = createBaseGetLedgerApiVersionRequest();
    return message;
  },
};

function createBaseGetLedgerApiVersionResponse(): GetLedgerApiVersionResponse {
  return { version: "", features: undefined };
}

export const GetLedgerApiVersionResponse: MessageFns<GetLedgerApiVersionResponse> = {
  encode(message: GetLedgerApiVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.features !== undefined) {
      FeaturesDescriptor.encode(message.features, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerApiVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerApiVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.features = FeaturesDescriptor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLedgerApiVersionResponse {
    return {
      version: isSet(object.version) ? gt.String(object.version) : "",
      features: isSet(object.features) ? FeaturesDescriptor.fromJSON(object.features) : undefined,
    };
  },

  toJSON(message: GetLedgerApiVersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.features !== undefined) {
      obj.features = FeaturesDescriptor.toJSON(message.features);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerApiVersionResponse>, I>>(base?: I): GetLedgerApiVersionResponse {
    return GetLedgerApiVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerApiVersionResponse>, I>>(object: I): GetLedgerApiVersionResponse {
    const message = createBaseGetLedgerApiVersionResponse();
    message.version = object.version ?? "";
    message.features = (object.features !== undefined && object.features !== null)
      ? FeaturesDescriptor.fromPartial(object.features)
      : undefined;
    return message;
  },
};

function createBaseFeaturesDescriptor(): FeaturesDescriptor {
  return {
    experimental: undefined,
    userManagement: undefined,
    partyManagement: undefined,
    offsetCheckpoint: undefined,
  };
}

export const FeaturesDescriptor: MessageFns<FeaturesDescriptor> = {
  encode(message: FeaturesDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.experimental !== undefined) {
      ExperimentalFeatures.encode(message.experimental, writer.uint32(10).fork()).join();
    }
    if (message.userManagement !== undefined) {
      UserManagementFeature.encode(message.userManagement, writer.uint32(18).fork()).join();
    }
    if (message.partyManagement !== undefined) {
      PartyManagementFeature.encode(message.partyManagement, writer.uint32(26).fork()).join();
    }
    if (message.offsetCheckpoint !== undefined) {
      OffsetCheckpointFeature.encode(message.offsetCheckpoint, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeaturesDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeaturesDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.experimental = ExperimentalFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userManagement = UserManagementFeature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.partyManagement = PartyManagementFeature.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.offsetCheckpoint = OffsetCheckpointFeature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeaturesDescriptor {
    return {
      experimental: isSet(object.experimental) ? ExperimentalFeatures.fromJSON(object.experimental) : undefined,
      userManagement: isSet(object.userManagement) ? UserManagementFeature.fromJSON(object.userManagement) : undefined,
      partyManagement: isSet(object.partyManagement)
        ? PartyManagementFeature.fromJSON(object.partyManagement)
        : undefined,
      offsetCheckpoint: isSet(object.offsetCheckpoint)
        ? OffsetCheckpointFeature.fromJSON(object.offsetCheckpoint)
        : undefined,
    };
  },

  toJSON(message: FeaturesDescriptor): unknown {
    const obj: any = {};
    if (message.experimental !== undefined) {
      obj.experimental = ExperimentalFeatures.toJSON(message.experimental);
    }
    if (message.userManagement !== undefined) {
      obj.userManagement = UserManagementFeature.toJSON(message.userManagement);
    }
    if (message.partyManagement !== undefined) {
      obj.partyManagement = PartyManagementFeature.toJSON(message.partyManagement);
    }
    if (message.offsetCheckpoint !== undefined) {
      obj.offsetCheckpoint = OffsetCheckpointFeature.toJSON(message.offsetCheckpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeaturesDescriptor>, I>>(base?: I): FeaturesDescriptor {
    return FeaturesDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeaturesDescriptor>, I>>(object: I): FeaturesDescriptor {
    const message = createBaseFeaturesDescriptor();
    message.experimental = (object.experimental !== undefined && object.experimental !== null)
      ? ExperimentalFeatures.fromPartial(object.experimental)
      : undefined;
    message.userManagement = (object.userManagement !== undefined && object.userManagement !== null)
      ? UserManagementFeature.fromPartial(object.userManagement)
      : undefined;
    message.partyManagement = (object.partyManagement !== undefined && object.partyManagement !== null)
      ? PartyManagementFeature.fromPartial(object.partyManagement)
      : undefined;
    message.offsetCheckpoint = (object.offsetCheckpoint !== undefined && object.offsetCheckpoint !== null)
      ? OffsetCheckpointFeature.fromPartial(object.offsetCheckpoint)
      : undefined;
    return message;
  },
};

function createBaseUserManagementFeature(): UserManagementFeature {
  return { supported: false, maxRightsPerUser: 0, maxUsersPageSize: 0 };
}

export const UserManagementFeature: MessageFns<UserManagementFeature> = {
  encode(message: UserManagementFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.supported !== false) {
      writer.uint32(8).bool(message.supported);
    }
    if (message.maxRightsPerUser !== 0) {
      writer.uint32(16).int32(message.maxRightsPerUser);
    }
    if (message.maxUsersPageSize !== 0) {
      writer.uint32(24).int32(message.maxUsersPageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserManagementFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserManagementFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.supported = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxRightsPerUser = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxUsersPageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserManagementFeature {
    return {
      supported: isSet(object.supported) ? gt.Boolean(object.supported) : false,
      maxRightsPerUser: isSet(object.maxRightsPerUser) ? gt.Number(object.maxRightsPerUser) : 0,
      maxUsersPageSize: isSet(object.maxUsersPageSize) ? gt.Number(object.maxUsersPageSize) : 0,
    };
  },

  toJSON(message: UserManagementFeature): unknown {
    const obj: any = {};
    if (message.supported !== false) {
      obj.supported = message.supported;
    }
    if (message.maxRightsPerUser !== 0) {
      obj.maxRightsPerUser = Math.round(message.maxRightsPerUser);
    }
    if (message.maxUsersPageSize !== 0) {
      obj.maxUsersPageSize = Math.round(message.maxUsersPageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserManagementFeature>, I>>(base?: I): UserManagementFeature {
    return UserManagementFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserManagementFeature>, I>>(object: I): UserManagementFeature {
    const message = createBaseUserManagementFeature();
    message.supported = object.supported ?? false;
    message.maxRightsPerUser = object.maxRightsPerUser ?? 0;
    message.maxUsersPageSize = object.maxUsersPageSize ?? 0;
    return message;
  },
};

function createBasePartyManagementFeature(): PartyManagementFeature {
  return { maxPartiesPageSize: 0 };
}

export const PartyManagementFeature: MessageFns<PartyManagementFeature> = {
  encode(message: PartyManagementFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPartiesPageSize !== 0) {
      writer.uint32(8).int32(message.maxPartiesPageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartyManagementFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartyManagementFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxPartiesPageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartyManagementFeature {
    return { maxPartiesPageSize: isSet(object.maxPartiesPageSize) ? gt.Number(object.maxPartiesPageSize) : 0 };
  },

  toJSON(message: PartyManagementFeature): unknown {
    const obj: any = {};
    if (message.maxPartiesPageSize !== 0) {
      obj.maxPartiesPageSize = Math.round(message.maxPartiesPageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartyManagementFeature>, I>>(base?: I): PartyManagementFeature {
    return PartyManagementFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartyManagementFeature>, I>>(object: I): PartyManagementFeature {
    const message = createBasePartyManagementFeature();
    message.maxPartiesPageSize = object.maxPartiesPageSize ?? 0;
    return message;
  },
};

function createBaseOffsetCheckpointFeature(): OffsetCheckpointFeature {
  return { maxOffsetCheckpointEmissionDelay: undefined };
}

export const OffsetCheckpointFeature: MessageFns<OffsetCheckpointFeature> = {
  encode(message: OffsetCheckpointFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxOffsetCheckpointEmissionDelay !== undefined) {
      Duration.encode(message.maxOffsetCheckpointEmissionDelay, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OffsetCheckpointFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffsetCheckpointFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.maxOffsetCheckpointEmissionDelay = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OffsetCheckpointFeature {
    return {
      maxOffsetCheckpointEmissionDelay: isSet(object.maxOffsetCheckpointEmissionDelay)
        ? Duration.fromJSON(object.maxOffsetCheckpointEmissionDelay)
        : undefined,
    };
  },

  toJSON(message: OffsetCheckpointFeature): unknown {
    const obj: any = {};
    if (message.maxOffsetCheckpointEmissionDelay !== undefined) {
      obj.maxOffsetCheckpointEmissionDelay = Duration.toJSON(message.maxOffsetCheckpointEmissionDelay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OffsetCheckpointFeature>, I>>(base?: I): OffsetCheckpointFeature {
    return OffsetCheckpointFeature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OffsetCheckpointFeature>, I>>(object: I): OffsetCheckpointFeature {
    const message = createBaseOffsetCheckpointFeature();
    message.maxOffsetCheckpointEmissionDelay =
      (object.maxOffsetCheckpointEmissionDelay !== undefined && object.maxOffsetCheckpointEmissionDelay !== null)
        ? Duration.fromPartial(object.maxOffsetCheckpointEmissionDelay)
        : undefined;
    return message;
  },
};

/** Allows clients to retrieve information about the ledger API version */
export interface VersionService {
  /** Read the Ledger API version */
  GetLedgerApiVersion(request: GetLedgerApiVersionRequest): Promise<GetLedgerApiVersionResponse>;
}

export const VersionServiceServiceName = "com.daml.ledger.api.v2.VersionService";
export class VersionServiceClientImpl implements VersionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || VersionServiceServiceName;
    this.rpc = rpc;
    this.GetLedgerApiVersion = this.GetLedgerApiVersion.bind(this);
  }
  GetLedgerApiVersion(request: GetLedgerApiVersionRequest): Promise<GetLedgerApiVersionResponse> {
    const data = GetLedgerApiVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLedgerApiVersion", data);
    return promise.then((data) => GetLedgerApiVersionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
