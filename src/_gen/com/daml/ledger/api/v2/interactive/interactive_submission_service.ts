// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/interactive/interactive_submission_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Timestamp } from "../../../../../../google/protobuf/timestamp";
import { Command, DisclosedContract, PrefetchContractKey } from "../commands";
import { PackageReference } from "../package_reference";
import { Value } from "../value";
import { GlobalKey } from "./interactive_submission_common_data";
import { Create, Node } from "./transaction/v1/interactive_submission_data";

export const protobufPackage = "com.daml.ledger.api.v2.interactive";

/**
 * [docs-entry-start: HashingSchemeVersion]
 * The hashing scheme version used when building the hash of the PreparedTransaction
 */
export enum HashingSchemeVersion {
  HASHING_SCHEME_VERSION_UNSPECIFIED = 0,
  HASHING_SCHEME_VERSION_V2 = 2,
  UNRECOGNIZED = -1,
}

export function hashingSchemeVersionFromJSON(object: any): HashingSchemeVersion {
  switch (object) {
    case 0:
    case "HASHING_SCHEME_VERSION_UNSPECIFIED":
      return HashingSchemeVersion.HASHING_SCHEME_VERSION_UNSPECIFIED;
    case 2:
    case "HASHING_SCHEME_VERSION_V2":
      return HashingSchemeVersion.HASHING_SCHEME_VERSION_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HashingSchemeVersion.UNRECOGNIZED;
  }
}

export function hashingSchemeVersionToJSON(object: HashingSchemeVersion): string {
  switch (object) {
    case HashingSchemeVersion.HASHING_SCHEME_VERSION_UNSPECIFIED:
      return "HASHING_SCHEME_VERSION_UNSPECIFIED";
    case HashingSchemeVersion.HASHING_SCHEME_VERSION_V2:
      return "HASHING_SCHEME_VERSION_V2";
    case HashingSchemeVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SigningAlgorithmSpec {
  SIGNING_ALGORITHM_SPEC_UNSPECIFIED = 0,
  /**
   * SIGNING_ALGORITHM_SPEC_ED25519 - EdDSA Signature based on Curve25519 with SHA-512
   * http://ed25519.cr.yp.to/
   */
  SIGNING_ALGORITHM_SPEC_ED25519 = 1,
  /** SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256 - Elliptic Curve Digital Signature Algorithm with SHA256 */
  SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256 = 2,
  /** SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384 - Elliptic Curve Digital Signature Algorithm with SHA384 */
  SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384 = 3,
  UNRECOGNIZED = -1,
}

export function signingAlgorithmSpecFromJSON(object: any): SigningAlgorithmSpec {
  switch (object) {
    case 0:
    case "SIGNING_ALGORITHM_SPEC_UNSPECIFIED":
      return SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_UNSPECIFIED;
    case 1:
    case "SIGNING_ALGORITHM_SPEC_ED25519":
      return SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_ED25519;
    case 2:
    case "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256":
      return SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256;
    case 3:
    case "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384":
      return SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SigningAlgorithmSpec.UNRECOGNIZED;
  }
}

export function signingAlgorithmSpecToJSON(object: SigningAlgorithmSpec): string {
  switch (object) {
    case SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_UNSPECIFIED:
      return "SIGNING_ALGORITHM_SPEC_UNSPECIFIED";
    case SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_ED25519:
      return "SIGNING_ALGORITHM_SPEC_ED25519";
    case SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256:
      return "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256";
    case SigningAlgorithmSpec.SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384:
      return "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384";
    case SigningAlgorithmSpec.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SignatureFormat {
  SIGNATURE_FORMAT_UNSPECIFIED = 0,
  /**
   * SIGNATURE_FORMAT_RAW - Signature scheme specific signature format
   * Legacy format no longer used, except for migrations
   */
  SIGNATURE_FORMAT_RAW = 1,
  /**
   * SIGNATURE_FORMAT_DER - ASN.1 + DER-encoding of the `r` and `s` integers, as defined in https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3
   * Used for ECDSA signatures
   */
  SIGNATURE_FORMAT_DER = 2,
  /**
   * SIGNATURE_FORMAT_CONCAT - Concatenation of the integers `r || s` in little-endian form, as defined in https://datatracker.ietf.org/doc/html/rfc8032#section-3.3
   * Note that this is different from the format defined in IEEE P1363, which uses concatenation in big-endian form.
   * Used for EdDSA signatures
   */
  SIGNATURE_FORMAT_CONCAT = 3,
  /** SIGNATURE_FORMAT_SYMBOLIC - Symbolic crypto, must only be used for testing */
  SIGNATURE_FORMAT_SYMBOLIC = 10000,
  UNRECOGNIZED = -1,
}

export function signatureFormatFromJSON(object: any): SignatureFormat {
  switch (object) {
    case 0:
    case "SIGNATURE_FORMAT_UNSPECIFIED":
      return SignatureFormat.SIGNATURE_FORMAT_UNSPECIFIED;
    case 1:
    case "SIGNATURE_FORMAT_RAW":
      return SignatureFormat.SIGNATURE_FORMAT_RAW;
    case 2:
    case "SIGNATURE_FORMAT_DER":
      return SignatureFormat.SIGNATURE_FORMAT_DER;
    case 3:
    case "SIGNATURE_FORMAT_CONCAT":
      return SignatureFormat.SIGNATURE_FORMAT_CONCAT;
    case 10000:
    case "SIGNATURE_FORMAT_SYMBOLIC":
      return SignatureFormat.SIGNATURE_FORMAT_SYMBOLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignatureFormat.UNRECOGNIZED;
  }
}

export function signatureFormatToJSON(object: SignatureFormat): string {
  switch (object) {
    case SignatureFormat.SIGNATURE_FORMAT_UNSPECIFIED:
      return "SIGNATURE_FORMAT_UNSPECIFIED";
    case SignatureFormat.SIGNATURE_FORMAT_RAW:
      return "SIGNATURE_FORMAT_RAW";
    case SignatureFormat.SIGNATURE_FORMAT_DER:
      return "SIGNATURE_FORMAT_DER";
    case SignatureFormat.SIGNATURE_FORMAT_CONCAT:
      return "SIGNATURE_FORMAT_CONCAT";
    case SignatureFormat.SIGNATURE_FORMAT_SYMBOLIC:
      return "SIGNATURE_FORMAT_SYMBOLIC";
    case SignatureFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PrepareSubmissionRequest {
  /**
   * Uniquely identifies the participant user that prepares the transaction.
   * Must be a valid UserIdString (as described in ``value.proto``).
   * Required unless authentication is used with a user token.
   * In that case, the token's user-id will be used for the request's user_id.
   */
  userId: string;
  /**
   * Uniquely identifies the command.
   * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
   * where act_as is interpreted as a set of party names.
   * The change ID can be used for matching the intended ledger changes with all their completions.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  commandId: string;
  /**
   * Individual elements of this atomic command. Must be non-empty.
   * Required
   */
  commands: Command[];
  /** Optional */
  minLedgerTime:
    | MinLedgerTime
    | undefined;
  /**
   * Set of parties on whose behalf the command should be executed, if submitted.
   * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
   * to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
   * and does not execute it. Therefore read authorization is sufficient even for actAs parties.
   * Note: This may change, and more specific authorization scope may be introduced in the future.
   * Each element must be a valid PartyIdString (as described in ``value.proto``).
   * Required, must be non-empty.
   */
  actAs: string[];
  /**
   * Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
   * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
   * Note: A command can only use contracts that are visible to at least
   * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
   * rules for fetch operations.
   * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
   * to read contract data on behalf of each of the given parties.
   * Optional
   */
  readAs: string[];
  /**
   * Additional contracts used to resolve contract & contract key lookups.
   * Optional
   */
  disclosedContracts: DisclosedContract[];
  /**
   * Must be a valid synchronizer id
   * Required
   */
  synchronizerId: string;
  /**
   * The package-id selection preference of the client for resolving
   * package names and interface instances in command submission and interpretation
   */
  packageIdSelectionPreference: string[];
  /**
   * When true, the response will contain additional details on how the transaction was encoded and hashed
   * This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
   */
  verboseHashing: boolean;
  /**
   * Fetches the contract keys into the caches to speed up the command processing.
   * Should only contain contract keys that are expected to be resolved during interpretation of the commands.
   * Keys of disclosed contracts do not need prefetching.
   *
   * Optional
   */
  prefetchContractKeys: PrefetchContractKey[];
}

export interface PrepareSubmissionResponse {
  /**
   * The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
   * Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
   */
  preparedTransaction:
    | PreparedTransaction
    | undefined;
  /**
   * Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
   * Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
   * May be removed in future versions
   */
  preparedTransactionHash: Uint8Array;
  /** The hashing scheme version used when building the hash */
  hashingSchemeVersion: HashingSchemeVersion;
  /**
   * Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
   * Note that there are no guarantees on the stability of the format or content of this field.
   * Its content should NOT be parsed and should only be used for troubleshooting purposes.
   */
  hashingDetails?: string | undefined;
}

export interface Signature {
  format: SignatureFormat;
  signature: Uint8Array;
  /** The fingerprint/id of the keypair used to create this signature and needed to verify. */
  signedBy: string;
  /** The signing algorithm specification used to produce this signature */
  signingAlgorithmSpec: SigningAlgorithmSpec;
}

/** Signatures provided by a single party */
export interface SinglePartySignatures {
  /** Submitting party */
  party: string;
  /** Signatures */
  signatures: Signature[];
}

/** Additional signatures provided by the submitting parties */
export interface PartySignatures {
  /** Additional signatures provided by all individual parties */
  signatures: SinglePartySignatures[];
}

export interface ExecuteSubmissionRequest {
  /**
   * the prepared transaction
   * Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
   * obtained from calling `prepareSubmission`.
   */
  preparedTransaction:
    | PreparedTransaction
    | undefined;
  /**
   * The party(ies) signatures that authorize the prepared submission to be executed by this node.
   * Each party can provide one or more signatures..
   * and one or more parties can sign.
   * Note that currently, only single party submissions are supported.
   */
  partySignatures:
    | PartySignatures
    | undefined;
  /**
   * Specifies the length of the deduplication period.
   * It is interpreted relative to the local clock at some point during the submission's processing.
   * Must be non-negative. Must not exceed the maximum deduplication time.
   */
  deduplicationDuration?:
    | Duration
    | undefined;
  /**
   * Specifies the start of the deduplication period by a completion stream offset (exclusive).
   * Must be a valid absolute offset (positive integer).
   */
  deduplicationOffset?:
    | number
    | undefined;
  /**
   * A unique identifier to distinguish completions for different submissions with the same change ID.
   * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
   * with the same change ID.
   * Must be a valid LedgerString (as described in ``value.proto``).
   *
   * Required
   */
  submissionId: string;
  /** See [PrepareSubmissionRequest.user_id] */
  userId: string;
  /** The hashing scheme version used when building the hash */
  hashingSchemeVersion: HashingSchemeVersion;
  /**
   * If set will influence the chosen ledger effective time but will not result in a submission delay so any override
   * should be scheduled to executed within the window allowed by synchronizer.
   */
  minLedgerTime: MinLedgerTime | undefined;
}

export interface ExecuteSubmissionResponse {
}

export interface MinLedgerTime {
  /**
   * Lower bound for the ledger time assigned to the resulting transaction.
   * The ledger time of a transaction is assigned as part of command interpretation.
   * Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
   * and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
   * The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
   * If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
   * by the submission timestamp, which is also assigned in the "prepare" step (this request),
   * but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
   * Must not be set at the same time as min_ledger_time_rel.
   * Optional
   */
  minLedgerTimeAbs?:
    | Date
    | undefined;
  /**
   * Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
   * Must not be set at the same time as min_ledger_time_abs.
   * Optional
   */
  minLedgerTimeRel?: Duration | undefined;
}

/** Prepared Transaction Message */
export interface PreparedTransaction {
  /** Daml Transaction representing the ledger effect if executed. See below */
  transaction:
    | DamlTransaction
    | undefined;
  /** Metadata context necessary to execute the transaction */
  metadata: Metadata | undefined;
}

/**
 * Transaction Metadata
 * Refer to the hashing documentation for information on how it should be hashed.
 */
export interface Metadata {
  submitterInfo: Metadata_SubmitterInfo | undefined;
  synchronizerId: string;
  mediatorGroup: number;
  transactionUuid: string;
  submissionTime: number;
  inputContracts: Metadata_InputContract[];
  /**
   * Where ledger time constraints are imposed during the execution of the contract they will be populated
   * in the fields below. These are optional because if the transaction does NOT depend on time, these values
   * do not need to be set.
   * The final ledger effective time used will be chosen when the command is submitted through the [execute] RPC.
   * If the ledger effective time is outside of any populated min/max bounds then a different transaction
   * can result, that will cause a confirmation message rejection.
   */
  minLedgerEffectiveTime?: number | undefined;
  maxLedgerEffectiveTime?:
    | number
    | undefined;
  /**
   * Contextual information needed to process the transaction but not signed, either because it's already indirectly
   * signed by signing the transaction, or because it doesn't impact the ledger state
   */
  globalKeyMapping: Metadata_GlobalKeyMappingEntry[];
}

export interface Metadata_SubmitterInfo {
  actAs: string[];
  commandId: string;
}

export interface Metadata_GlobalKeyMappingEntry {
  key: GlobalKey | undefined;
  value?: Value | undefined;
}

export interface Metadata_InputContract {
  /** When new versions will be added, they will show here */
  v1?: Create | undefined;
  createdAt: number;
  driverMetadata: Uint8Array;
}

/**
 * Daml Transaction.
 * This represents the effect on the ledger if this transaction is successfully committed.
 */
export interface DamlTransaction {
  /** Transaction version, will be >= max(nodes version) */
  version: string;
  /** Root nodes of the transaction */
  roots: string[];
  /** List of nodes in the transaction */
  nodes: DamlTransaction_Node[];
  /** Node seeds are values associated with certain nodes used for generating cryptographic salts */
  nodeSeeds: DamlTransaction_NodeSeed[];
}

export interface DamlTransaction_NodeSeed {
  nodeId: number;
  seed: Uint8Array;
}

/**
 * A transaction may contain nodes with different versions.
 * Each node must be hashed using the hashing algorithm corresponding to its specific version.
 * [docs-entry-start: DamlTransaction.Node]
 */
export interface DamlTransaction_Node {
  nodeId: string;
  /**
   * Start at 1000 so we can add more fields before if necessary
   * When new versions will be added, they will show here
   */
  v1?: Node | undefined;
}

export interface GetPreferredPackageVersionRequest {
  /**
   * The parties whose participants' vetting state should be considered when resolving the preferred package.
   * Required
   */
  parties: string[];
  /**
   * The package-name for which the preferred package should be resolved.
   * Required
   */
  packageName: string;
  /**
   * The synchronizer whose vetting state to use for resolving this query.
   * If not specified, the vetting state of all the synchronizers the participant is connected to will be used.
   * Optional
   */
  synchronizerId: string;
  /**
   * The timestamp at which the package vetting validity should be computed
   * on the latest topology snapshot as seen by the participant.
   * If not provided, the participant's current clock time is used.
   * Optional
   */
  vettingValidAt: Date | undefined;
}

export interface GetPreferredPackageVersionResponse {
  /**
   * Not populated when no preferred package is found
   * Optional
   */
  packagePreference: PackagePreference | undefined;
}

export interface PackagePreference {
  /**
   * The package reference of the preferred package.
   * Required
   */
  packageReference:
    | PackageReference
    | undefined;
  /**
   * The synchronizer for which the preferred package was computed.
   * If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
   * Required
   */
  synchronizerId: string;
}

function createBasePrepareSubmissionRequest(): PrepareSubmissionRequest {
  return {
    userId: "",
    commandId: "",
    commands: [],
    minLedgerTime: undefined,
    actAs: [],
    readAs: [],
    disclosedContracts: [],
    synchronizerId: "",
    packageIdSelectionPreference: [],
    verboseHashing: false,
    prefetchContractKeys: [],
  };
}

export const PrepareSubmissionRequest: MessageFns<PrepareSubmissionRequest> = {
  encode(message: PrepareSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    for (const v of message.commands) {
      Command.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.minLedgerTime !== undefined) {
      MinLedgerTime.encode(message.minLedgerTime, writer.uint32(34).fork()).join();
    }
    for (const v of message.actAs) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.readAs) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.disclosedContracts) {
      DisclosedContract.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.synchronizerId !== "") {
      writer.uint32(66).string(message.synchronizerId);
    }
    for (const v of message.packageIdSelectionPreference) {
      writer.uint32(74).string(v!);
    }
    if (message.verboseHashing !== false) {
      writer.uint32(80).bool(message.verboseHashing);
    }
    for (const v of message.prefetchContractKeys) {
      PrefetchContractKey.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commands.push(Command.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minLedgerTime = MinLedgerTime.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actAs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.readAs.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.disclosedContracts.push(DisclosedContract.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.packageIdSelectionPreference.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.verboseHashing = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.prefetchContractKeys.push(PrefetchContractKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareSubmissionRequest {
    return {
      userId: isSet(object.userId) ? gt.String(object.userId) : "",
      commandId: isSet(object.commandId) ? gt.String(object.commandId) : "",
      commands: gt.Array.isArray(object?.commands) ? object.commands.map((e: any) => Command.fromJSON(e)) : [],
      minLedgerTime: isSet(object.minLedgerTime) ? MinLedgerTime.fromJSON(object.minLedgerTime) : undefined,
      actAs: gt.Array.isArray(object?.actAs) ? object.actAs.map((e: any) => gt.String(e)) : [],
      readAs: gt.Array.isArray(object?.readAs) ? object.readAs.map((e: any) => gt.String(e)) : [],
      disclosedContracts: gt.Array.isArray(object?.disclosedContracts)
        ? object.disclosedContracts.map((e: any) => DisclosedContract.fromJSON(e))
        : [],
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      packageIdSelectionPreference: gt.Array.isArray(object?.packageIdSelectionPreference)
        ? object.packageIdSelectionPreference.map((e: any) => gt.String(e))
        : [],
      verboseHashing: isSet(object.verboseHashing) ? gt.Boolean(object.verboseHashing) : false,
      prefetchContractKeys: gt.Array.isArray(object?.prefetchContractKeys)
        ? object.prefetchContractKeys.map((e: any) => PrefetchContractKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PrepareSubmissionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => Command.toJSON(e));
    }
    if (message.minLedgerTime !== undefined) {
      obj.minLedgerTime = MinLedgerTime.toJSON(message.minLedgerTime);
    }
    if (message.actAs?.length) {
      obj.actAs = message.actAs;
    }
    if (message.readAs?.length) {
      obj.readAs = message.readAs;
    }
    if (message.disclosedContracts?.length) {
      obj.disclosedContracts = message.disclosedContracts.map((e) => DisclosedContract.toJSON(e));
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.packageIdSelectionPreference?.length) {
      obj.packageIdSelectionPreference = message.packageIdSelectionPreference;
    }
    if (message.verboseHashing !== false) {
      obj.verboseHashing = message.verboseHashing;
    }
    if (message.prefetchContractKeys?.length) {
      obj.prefetchContractKeys = message.prefetchContractKeys.map((e) => PrefetchContractKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareSubmissionRequest>, I>>(base?: I): PrepareSubmissionRequest {
    return PrepareSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareSubmissionRequest>, I>>(object: I): PrepareSubmissionRequest {
    const message = createBasePrepareSubmissionRequest();
    message.userId = object.userId ?? "";
    message.commandId = object.commandId ?? "";
    message.commands = object.commands?.map((e) => Command.fromPartial(e)) || [];
    message.minLedgerTime = (object.minLedgerTime !== undefined && object.minLedgerTime !== null)
      ? MinLedgerTime.fromPartial(object.minLedgerTime)
      : undefined;
    message.actAs = object.actAs?.map((e) => e) || [];
    message.readAs = object.readAs?.map((e) => e) || [];
    message.disclosedContracts = object.disclosedContracts?.map((e) => DisclosedContract.fromPartial(e)) || [];
    message.synchronizerId = object.synchronizerId ?? "";
    message.packageIdSelectionPreference = object.packageIdSelectionPreference?.map((e) => e) || [];
    message.verboseHashing = object.verboseHashing ?? false;
    message.prefetchContractKeys = object.prefetchContractKeys?.map((e) => PrefetchContractKey.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareSubmissionResponse(): PrepareSubmissionResponse {
  return {
    preparedTransaction: undefined,
    preparedTransactionHash: new Uint8Array(0),
    hashingSchemeVersion: 0,
    hashingDetails: undefined,
  };
}

export const PrepareSubmissionResponse: MessageFns<PrepareSubmissionResponse> = {
  encode(message: PrepareSubmissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preparedTransaction !== undefined) {
      PreparedTransaction.encode(message.preparedTransaction, writer.uint32(10).fork()).join();
    }
    if (message.preparedTransactionHash.length !== 0) {
      writer.uint32(18).bytes(message.preparedTransactionHash);
    }
    if (message.hashingSchemeVersion !== 0) {
      writer.uint32(24).int32(message.hashingSchemeVersion);
    }
    if (message.hashingDetails !== undefined) {
      writer.uint32(34).string(message.hashingDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareSubmissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareSubmissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preparedTransaction = PreparedTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preparedTransactionHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hashingSchemeVersion = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashingDetails = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareSubmissionResponse {
    return {
      preparedTransaction: isSet(object.preparedTransaction)
        ? PreparedTransaction.fromJSON(object.preparedTransaction)
        : undefined,
      preparedTransactionHash: isSet(object.preparedTransactionHash)
        ? bytesFromBase64(object.preparedTransactionHash)
        : new Uint8Array(0),
      hashingSchemeVersion: isSet(object.hashingSchemeVersion)
        ? hashingSchemeVersionFromJSON(object.hashingSchemeVersion)
        : 0,
      hashingDetails: isSet(object.hashingDetails) ? gt.String(object.hashingDetails) : undefined,
    };
  },

  toJSON(message: PrepareSubmissionResponse): unknown {
    const obj: any = {};
    if (message.preparedTransaction !== undefined) {
      obj.preparedTransaction = PreparedTransaction.toJSON(message.preparedTransaction);
    }
    if (message.preparedTransactionHash.length !== 0) {
      obj.preparedTransactionHash = base64FromBytes(message.preparedTransactionHash);
    }
    if (message.hashingSchemeVersion !== 0) {
      obj.hashingSchemeVersion = hashingSchemeVersionToJSON(message.hashingSchemeVersion);
    }
    if (message.hashingDetails !== undefined) {
      obj.hashingDetails = message.hashingDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareSubmissionResponse>, I>>(base?: I): PrepareSubmissionResponse {
    return PrepareSubmissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareSubmissionResponse>, I>>(object: I): PrepareSubmissionResponse {
    const message = createBasePrepareSubmissionResponse();
    message.preparedTransaction = (object.preparedTransaction !== undefined && object.preparedTransaction !== null)
      ? PreparedTransaction.fromPartial(object.preparedTransaction)
      : undefined;
    message.preparedTransactionHash = object.preparedTransactionHash ?? new Uint8Array(0);
    message.hashingSchemeVersion = object.hashingSchemeVersion ?? 0;
    message.hashingDetails = object.hashingDetails ?? undefined;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { format: 0, signature: new Uint8Array(0), signedBy: "", signingAlgorithmSpec: 0 };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.signedBy !== "") {
      writer.uint32(26).string(message.signedBy);
    }
    if (message.signingAlgorithmSpec !== 0) {
      writer.uint32(32).int32(message.signingAlgorithmSpec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signedBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.signingAlgorithmSpec = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      format: isSet(object.format) ? signatureFormatFromJSON(object.format) : 0,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      signedBy: isSet(object.signedBy) ? gt.String(object.signedBy) : "",
      signingAlgorithmSpec: isSet(object.signingAlgorithmSpec)
        ? signingAlgorithmSpecFromJSON(object.signingAlgorithmSpec)
        : 0,
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = signatureFormatToJSON(message.format);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.signedBy !== "") {
      obj.signedBy = message.signedBy;
    }
    if (message.signingAlgorithmSpec !== 0) {
      obj.signingAlgorithmSpec = signingAlgorithmSpecToJSON(message.signingAlgorithmSpec);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(object: I): Signature {
    const message = createBaseSignature();
    message.format = object.format ?? 0;
    message.signature = object.signature ?? new Uint8Array(0);
    message.signedBy = object.signedBy ?? "";
    message.signingAlgorithmSpec = object.signingAlgorithmSpec ?? 0;
    return message;
  },
};

function createBaseSinglePartySignatures(): SinglePartySignatures {
  return { party: "", signatures: [] };
}

export const SinglePartySignatures: MessageFns<SinglePartySignatures> = {
  encode(message: SinglePartySignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.party !== "") {
      writer.uint32(10).string(message.party);
    }
    for (const v of message.signatures) {
      Signature.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePartySignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePartySignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.party = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signatures.push(Signature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePartySignatures {
    return {
      party: isSet(object.party) ? gt.String(object.party) : "",
      signatures: gt.Array.isArray(object?.signatures) ? object.signatures.map((e: any) => Signature.fromJSON(e)) : [],
    };
  },

  toJSON(message: SinglePartySignatures): unknown {
    const obj: any = {};
    if (message.party !== "") {
      obj.party = message.party;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePartySignatures>, I>>(base?: I): SinglePartySignatures {
    return SinglePartySignatures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePartySignatures>, I>>(object: I): SinglePartySignatures {
    const message = createBaseSinglePartySignatures();
    message.party = object.party ?? "";
    message.signatures = object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    return message;
  },
};

function createBasePartySignatures(): PartySignatures {
  return { signatures: [] };
}

export const PartySignatures: MessageFns<PartySignatures> = {
  encode(message: PartySignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signatures) {
      SinglePartySignatures.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartySignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartySignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signatures.push(SinglePartySignatures.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartySignatures {
    return {
      signatures: gt.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => SinglePartySignatures.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PartySignatures): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => SinglePartySignatures.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartySignatures>, I>>(base?: I): PartySignatures {
    return PartySignatures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartySignatures>, I>>(object: I): PartySignatures {
    const message = createBasePartySignatures();
    message.signatures = object.signatures?.map((e) => SinglePartySignatures.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecuteSubmissionRequest(): ExecuteSubmissionRequest {
  return {
    preparedTransaction: undefined,
    partySignatures: undefined,
    deduplicationDuration: undefined,
    deduplicationOffset: undefined,
    submissionId: "",
    userId: "",
    hashingSchemeVersion: 0,
    minLedgerTime: undefined,
  };
}

export const ExecuteSubmissionRequest: MessageFns<ExecuteSubmissionRequest> = {
  encode(message: ExecuteSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preparedTransaction !== undefined) {
      PreparedTransaction.encode(message.preparedTransaction, writer.uint32(10).fork()).join();
    }
    if (message.partySignatures !== undefined) {
      PartySignatures.encode(message.partySignatures, writer.uint32(18).fork()).join();
    }
    if (message.deduplicationDuration !== undefined) {
      Duration.encode(message.deduplicationDuration, writer.uint32(26).fork()).join();
    }
    if (message.deduplicationOffset !== undefined) {
      writer.uint32(32).int64(message.deduplicationOffset);
    }
    if (message.submissionId !== "") {
      writer.uint32(42).string(message.submissionId);
    }
    if (message.userId !== "") {
      writer.uint32(50).string(message.userId);
    }
    if (message.hashingSchemeVersion !== 0) {
      writer.uint32(56).int32(message.hashingSchemeVersion);
    }
    if (message.minLedgerTime !== undefined) {
      MinLedgerTime.encode(message.minLedgerTime, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preparedTransaction = PreparedTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partySignatures = PartySignatures.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deduplicationDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deduplicationOffset = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.submissionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.hashingSchemeVersion = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minLedgerTime = MinLedgerTime.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteSubmissionRequest {
    return {
      preparedTransaction: isSet(object.preparedTransaction)
        ? PreparedTransaction.fromJSON(object.preparedTransaction)
        : undefined,
      partySignatures: isSet(object.partySignatures) ? PartySignatures.fromJSON(object.partySignatures) : undefined,
      deduplicationDuration: isSet(object.deduplicationDuration)
        ? Duration.fromJSON(object.deduplicationDuration)
        : undefined,
      deduplicationOffset: isSet(object.deduplicationOffset) ? gt.Number(object.deduplicationOffset) : undefined,
      submissionId: isSet(object.submissionId) ? gt.String(object.submissionId) : "",
      userId: isSet(object.userId) ? gt.String(object.userId) : "",
      hashingSchemeVersion: isSet(object.hashingSchemeVersion)
        ? hashingSchemeVersionFromJSON(object.hashingSchemeVersion)
        : 0,
      minLedgerTime: isSet(object.minLedgerTime) ? MinLedgerTime.fromJSON(object.minLedgerTime) : undefined,
    };
  },

  toJSON(message: ExecuteSubmissionRequest): unknown {
    const obj: any = {};
    if (message.preparedTransaction !== undefined) {
      obj.preparedTransaction = PreparedTransaction.toJSON(message.preparedTransaction);
    }
    if (message.partySignatures !== undefined) {
      obj.partySignatures = PartySignatures.toJSON(message.partySignatures);
    }
    if (message.deduplicationDuration !== undefined) {
      obj.deduplicationDuration = Duration.toJSON(message.deduplicationDuration);
    }
    if (message.deduplicationOffset !== undefined) {
      obj.deduplicationOffset = Math.round(message.deduplicationOffset);
    }
    if (message.submissionId !== "") {
      obj.submissionId = message.submissionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.hashingSchemeVersion !== 0) {
      obj.hashingSchemeVersion = hashingSchemeVersionToJSON(message.hashingSchemeVersion);
    }
    if (message.minLedgerTime !== undefined) {
      obj.minLedgerTime = MinLedgerTime.toJSON(message.minLedgerTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteSubmissionRequest>, I>>(base?: I): ExecuteSubmissionRequest {
    return ExecuteSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteSubmissionRequest>, I>>(object: I): ExecuteSubmissionRequest {
    const message = createBaseExecuteSubmissionRequest();
    message.preparedTransaction = (object.preparedTransaction !== undefined && object.preparedTransaction !== null)
      ? PreparedTransaction.fromPartial(object.preparedTransaction)
      : undefined;
    message.partySignatures = (object.partySignatures !== undefined && object.partySignatures !== null)
      ? PartySignatures.fromPartial(object.partySignatures)
      : undefined;
    message.deduplicationDuration =
      (object.deduplicationDuration !== undefined && object.deduplicationDuration !== null)
        ? Duration.fromPartial(object.deduplicationDuration)
        : undefined;
    message.deduplicationOffset = object.deduplicationOffset ?? undefined;
    message.submissionId = object.submissionId ?? "";
    message.userId = object.userId ?? "";
    message.hashingSchemeVersion = object.hashingSchemeVersion ?? 0;
    message.minLedgerTime = (object.minLedgerTime !== undefined && object.minLedgerTime !== null)
      ? MinLedgerTime.fromPartial(object.minLedgerTime)
      : undefined;
    return message;
  },
};

function createBaseExecuteSubmissionResponse(): ExecuteSubmissionResponse {
  return {};
}

export const ExecuteSubmissionResponse: MessageFns<ExecuteSubmissionResponse> = {
  encode(_: ExecuteSubmissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteSubmissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteSubmissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExecuteSubmissionResponse {
    return {};
  },

  toJSON(_: ExecuteSubmissionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteSubmissionResponse>, I>>(base?: I): ExecuteSubmissionResponse {
    return ExecuteSubmissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteSubmissionResponse>, I>>(_: I): ExecuteSubmissionResponse {
    const message = createBaseExecuteSubmissionResponse();
    return message;
  },
};

function createBaseMinLedgerTime(): MinLedgerTime {
  return { minLedgerTimeAbs: undefined, minLedgerTimeRel: undefined };
}

export const MinLedgerTime: MessageFns<MinLedgerTime> = {
  encode(message: MinLedgerTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minLedgerTimeAbs !== undefined) {
      Timestamp.encode(toTimestamp(message.minLedgerTimeAbs), writer.uint32(10).fork()).join();
    }
    if (message.minLedgerTimeRel !== undefined) {
      Duration.encode(message.minLedgerTimeRel, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinLedgerTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinLedgerTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minLedgerTimeAbs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.minLedgerTimeRel = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinLedgerTime {
    return {
      minLedgerTimeAbs: isSet(object.minLedgerTimeAbs) ? fromJsonTimestamp(object.minLedgerTimeAbs) : undefined,
      minLedgerTimeRel: isSet(object.minLedgerTimeRel) ? Duration.fromJSON(object.minLedgerTimeRel) : undefined,
    };
  },

  toJSON(message: MinLedgerTime): unknown {
    const obj: any = {};
    if (message.minLedgerTimeAbs !== undefined) {
      obj.minLedgerTimeAbs = message.minLedgerTimeAbs.toISOString();
    }
    if (message.minLedgerTimeRel !== undefined) {
      obj.minLedgerTimeRel = Duration.toJSON(message.minLedgerTimeRel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MinLedgerTime>, I>>(base?: I): MinLedgerTime {
    return MinLedgerTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MinLedgerTime>, I>>(object: I): MinLedgerTime {
    const message = createBaseMinLedgerTime();
    message.minLedgerTimeAbs = object.minLedgerTimeAbs ?? undefined;
    message.minLedgerTimeRel = (object.minLedgerTimeRel !== undefined && object.minLedgerTimeRel !== null)
      ? Duration.fromPartial(object.minLedgerTimeRel)
      : undefined;
    return message;
  },
};

function createBasePreparedTransaction(): PreparedTransaction {
  return { transaction: undefined, metadata: undefined };
}

export const PreparedTransaction: MessageFns<PreparedTransaction> = {
  encode(message: PreparedTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      DamlTransaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreparedTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreparedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = DamlTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreparedTransaction {
    return {
      transaction: isSet(object.transaction) ? DamlTransaction.fromJSON(object.transaction) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: PreparedTransaction): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = DamlTransaction.toJSON(message.transaction);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreparedTransaction>, I>>(base?: I): PreparedTransaction {
    return PreparedTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreparedTransaction>, I>>(object: I): PreparedTransaction {
    const message = createBasePreparedTransaction();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? DamlTransaction.fromPartial(object.transaction)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return {
    submitterInfo: undefined,
    synchronizerId: "",
    mediatorGroup: 0,
    transactionUuid: "",
    submissionTime: 0,
    inputContracts: [],
    minLedgerEffectiveTime: undefined,
    maxLedgerEffectiveTime: undefined,
    globalKeyMapping: [],
  };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submitterInfo !== undefined) {
      Metadata_SubmitterInfo.encode(message.submitterInfo, writer.uint32(18).fork()).join();
    }
    if (message.synchronizerId !== "") {
      writer.uint32(26).string(message.synchronizerId);
    }
    if (message.mediatorGroup !== 0) {
      writer.uint32(32).uint32(message.mediatorGroup);
    }
    if (message.transactionUuid !== "") {
      writer.uint32(42).string(message.transactionUuid);
    }
    if (message.submissionTime !== 0) {
      writer.uint32(48).uint64(message.submissionTime);
    }
    for (const v of message.inputContracts) {
      Metadata_InputContract.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.minLedgerEffectiveTime !== undefined) {
      writer.uint32(72).uint64(message.minLedgerEffectiveTime);
    }
    if (message.maxLedgerEffectiveTime !== undefined) {
      writer.uint32(80).uint64(message.maxLedgerEffectiveTime);
    }
    for (const v of message.globalKeyMapping) {
      Metadata_GlobalKeyMappingEntry.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.submitterInfo = Metadata_SubmitterInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mediatorGroup = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionUuid = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.submissionTime = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputContracts.push(Metadata_InputContract.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.minLedgerEffectiveTime = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxLedgerEffectiveTime = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.globalKeyMapping.push(Metadata_GlobalKeyMappingEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      submitterInfo: isSet(object.submitterInfo) ? Metadata_SubmitterInfo.fromJSON(object.submitterInfo) : undefined,
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      mediatorGroup: isSet(object.mediatorGroup) ? gt.Number(object.mediatorGroup) : 0,
      transactionUuid: isSet(object.transactionUuid) ? gt.String(object.transactionUuid) : "",
      submissionTime: isSet(object.submissionTime) ? gt.Number(object.submissionTime) : 0,
      inputContracts: gt.Array.isArray(object?.inputContracts)
        ? object.inputContracts.map((e: any) => Metadata_InputContract.fromJSON(e))
        : [],
      minLedgerEffectiveTime: isSet(object.minLedgerEffectiveTime)
        ? gt.Number(object.minLedgerEffectiveTime)
        : undefined,
      maxLedgerEffectiveTime: isSet(object.maxLedgerEffectiveTime)
        ? gt.Number(object.maxLedgerEffectiveTime)
        : undefined,
      globalKeyMapping: gt.Array.isArray(object?.globalKeyMapping)
        ? object.globalKeyMapping.map((e: any) => Metadata_GlobalKeyMappingEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.submitterInfo !== undefined) {
      obj.submitterInfo = Metadata_SubmitterInfo.toJSON(message.submitterInfo);
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.mediatorGroup !== 0) {
      obj.mediatorGroup = Math.round(message.mediatorGroup);
    }
    if (message.transactionUuid !== "") {
      obj.transactionUuid = message.transactionUuid;
    }
    if (message.submissionTime !== 0) {
      obj.submissionTime = Math.round(message.submissionTime);
    }
    if (message.inputContracts?.length) {
      obj.inputContracts = message.inputContracts.map((e) => Metadata_InputContract.toJSON(e));
    }
    if (message.minLedgerEffectiveTime !== undefined) {
      obj.minLedgerEffectiveTime = Math.round(message.minLedgerEffectiveTime);
    }
    if (message.maxLedgerEffectiveTime !== undefined) {
      obj.maxLedgerEffectiveTime = Math.round(message.maxLedgerEffectiveTime);
    }
    if (message.globalKeyMapping?.length) {
      obj.globalKeyMapping = message.globalKeyMapping.map((e) => Metadata_GlobalKeyMappingEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.submitterInfo = (object.submitterInfo !== undefined && object.submitterInfo !== null)
      ? Metadata_SubmitterInfo.fromPartial(object.submitterInfo)
      : undefined;
    message.synchronizerId = object.synchronizerId ?? "";
    message.mediatorGroup = object.mediatorGroup ?? 0;
    message.transactionUuid = object.transactionUuid ?? "";
    message.submissionTime = object.submissionTime ?? 0;
    message.inputContracts = object.inputContracts?.map((e) => Metadata_InputContract.fromPartial(e)) || [];
    message.minLedgerEffectiveTime = object.minLedgerEffectiveTime ?? undefined;
    message.maxLedgerEffectiveTime = object.maxLedgerEffectiveTime ?? undefined;
    message.globalKeyMapping = object.globalKeyMapping?.map((e) => Metadata_GlobalKeyMappingEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetadata_SubmitterInfo(): Metadata_SubmitterInfo {
  return { actAs: [], commandId: "" };
}

export const Metadata_SubmitterInfo: MessageFns<Metadata_SubmitterInfo> = {
  encode(message: Metadata_SubmitterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actAs) {
      writer.uint32(10).string(v!);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_SubmitterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_SubmitterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actAs.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_SubmitterInfo {
    return {
      actAs: gt.Array.isArray(object?.actAs) ? object.actAs.map((e: any) => gt.String(e)) : [],
      commandId: isSet(object.commandId) ? gt.String(object.commandId) : "",
    };
  },

  toJSON(message: Metadata_SubmitterInfo): unknown {
    const obj: any = {};
    if (message.actAs?.length) {
      obj.actAs = message.actAs;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_SubmitterInfo>, I>>(base?: I): Metadata_SubmitterInfo {
    return Metadata_SubmitterInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_SubmitterInfo>, I>>(object: I): Metadata_SubmitterInfo {
    const message = createBaseMetadata_SubmitterInfo();
    message.actAs = object.actAs?.map((e) => e) || [];
    message.commandId = object.commandId ?? "";
    return message;
  },
};

function createBaseMetadata_GlobalKeyMappingEntry(): Metadata_GlobalKeyMappingEntry {
  return { key: undefined, value: undefined };
}

export const Metadata_GlobalKeyMappingEntry: MessageFns<Metadata_GlobalKeyMappingEntry> = {
  encode(message: Metadata_GlobalKeyMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      GlobalKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_GlobalKeyMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_GlobalKeyMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = GlobalKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_GlobalKeyMappingEntry {
    return {
      key: isSet(object.key) ? GlobalKey.fromJSON(object.key) : undefined,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Metadata_GlobalKeyMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = GlobalKey.toJSON(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_GlobalKeyMappingEntry>, I>>(base?: I): Metadata_GlobalKeyMappingEntry {
    return Metadata_GlobalKeyMappingEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_GlobalKeyMappingEntry>, I>>(
    object: I,
  ): Metadata_GlobalKeyMappingEntry {
    const message = createBaseMetadata_GlobalKeyMappingEntry();
    message.key = (object.key !== undefined && object.key !== null) ? GlobalKey.fromPartial(object.key) : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseMetadata_InputContract(): Metadata_InputContract {
  return { v1: undefined, createdAt: 0, driverMetadata: new Uint8Array(0) };
}

export const Metadata_InputContract: MessageFns<Metadata_InputContract> = {
  encode(message: Metadata_InputContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.v1 !== undefined) {
      Create.encode(message.v1, writer.uint32(10).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(8000).uint64(message.createdAt);
    }
    if (message.driverMetadata.length !== 0) {
      writer.uint32(8010).bytes(message.driverMetadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_InputContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_InputContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.v1 = Create.decode(reader, reader.uint32());
          continue;
        }
        case 1000: {
          if (tag !== 8000) {
            break;
          }

          message.createdAt = longToNumber(reader.uint64());
          continue;
        }
        case 1001: {
          if (tag !== 8010) {
            break;
          }

          message.driverMetadata = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_InputContract {
    return {
      v1: isSet(object.v1) ? Create.fromJSON(object.v1) : undefined,
      createdAt: isSet(object.createdAt) ? gt.Number(object.createdAt) : 0,
      driverMetadata: isSet(object.driverMetadata) ? bytesFromBase64(object.driverMetadata) : new Uint8Array(0),
    };
  },

  toJSON(message: Metadata_InputContract): unknown {
    const obj: any = {};
    if (message.v1 !== undefined) {
      obj.v1 = Create.toJSON(message.v1);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.driverMetadata.length !== 0) {
      obj.driverMetadata = base64FromBytes(message.driverMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_InputContract>, I>>(base?: I): Metadata_InputContract {
    return Metadata_InputContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_InputContract>, I>>(object: I): Metadata_InputContract {
    const message = createBaseMetadata_InputContract();
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? Create.fromPartial(object.v1) : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.driverMetadata = object.driverMetadata ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDamlTransaction(): DamlTransaction {
  return { version: "", roots: [], nodes: [], nodeSeeds: [] };
}

export const DamlTransaction: MessageFns<DamlTransaction> = {
  encode(message: DamlTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.roots) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.nodes) {
      DamlTransaction_Node.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.nodeSeeds) {
      DamlTransaction_NodeSeed.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DamlTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDamlTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roots.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodes.push(DamlTransaction_Node.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodeSeeds.push(DamlTransaction_NodeSeed.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DamlTransaction {
    return {
      version: isSet(object.version) ? gt.String(object.version) : "",
      roots: gt.Array.isArray(object?.roots) ? object.roots.map((e: any) => gt.String(e)) : [],
      nodes: gt.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => DamlTransaction_Node.fromJSON(e)) : [],
      nodeSeeds: gt.Array.isArray(object?.nodeSeeds)
        ? object.nodeSeeds.map((e: any) => DamlTransaction_NodeSeed.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DamlTransaction): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.roots?.length) {
      obj.roots = message.roots;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => DamlTransaction_Node.toJSON(e));
    }
    if (message.nodeSeeds?.length) {
      obj.nodeSeeds = message.nodeSeeds.map((e) => DamlTransaction_NodeSeed.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DamlTransaction>, I>>(base?: I): DamlTransaction {
    return DamlTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DamlTransaction>, I>>(object: I): DamlTransaction {
    const message = createBaseDamlTransaction();
    message.version = object.version ?? "";
    message.roots = object.roots?.map((e) => e) || [];
    message.nodes = object.nodes?.map((e) => DamlTransaction_Node.fromPartial(e)) || [];
    message.nodeSeeds = object.nodeSeeds?.map((e) => DamlTransaction_NodeSeed.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDamlTransaction_NodeSeed(): DamlTransaction_NodeSeed {
  return { nodeId: 0, seed: new Uint8Array(0) };
}

export const DamlTransaction_NodeSeed: MessageFns<DamlTransaction_NodeSeed> = {
  encode(message: DamlTransaction_NodeSeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0) {
      writer.uint32(8).int32(message.nodeId);
    }
    if (message.seed.length !== 0) {
      writer.uint32(18).bytes(message.seed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DamlTransaction_NodeSeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDamlTransaction_NodeSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seed = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DamlTransaction_NodeSeed {
    return {
      nodeId: isSet(object.nodeId) ? gt.Number(object.nodeId) : 0,
      seed: isSet(object.seed) ? bytesFromBase64(object.seed) : new Uint8Array(0),
    };
  },

  toJSON(message: DamlTransaction_NodeSeed): unknown {
    const obj: any = {};
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.seed.length !== 0) {
      obj.seed = base64FromBytes(message.seed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DamlTransaction_NodeSeed>, I>>(base?: I): DamlTransaction_NodeSeed {
    return DamlTransaction_NodeSeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DamlTransaction_NodeSeed>, I>>(object: I): DamlTransaction_NodeSeed {
    const message = createBaseDamlTransaction_NodeSeed();
    message.nodeId = object.nodeId ?? 0;
    message.seed = object.seed ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDamlTransaction_Node(): DamlTransaction_Node {
  return { nodeId: "", v1: undefined };
}

export const DamlTransaction_Node: MessageFns<DamlTransaction_Node> = {
  encode(message: DamlTransaction_Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.v1 !== undefined) {
      Node.encode(message.v1, writer.uint32(8002).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DamlTransaction_Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDamlTransaction_Node();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 1000: {
          if (tag !== 8002) {
            break;
          }

          message.v1 = Node.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DamlTransaction_Node {
    return {
      nodeId: isSet(object.nodeId) ? gt.String(object.nodeId) : "",
      v1: isSet(object.v1) ? Node.fromJSON(object.v1) : undefined,
    };
  },

  toJSON(message: DamlTransaction_Node): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.v1 !== undefined) {
      obj.v1 = Node.toJSON(message.v1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DamlTransaction_Node>, I>>(base?: I): DamlTransaction_Node {
    return DamlTransaction_Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DamlTransaction_Node>, I>>(object: I): DamlTransaction_Node {
    const message = createBaseDamlTransaction_Node();
    message.nodeId = object.nodeId ?? "";
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? Node.fromPartial(object.v1) : undefined;
    return message;
  },
};

function createBaseGetPreferredPackageVersionRequest(): GetPreferredPackageVersionRequest {
  return { parties: [], packageName: "", synchronizerId: "", vettingValidAt: undefined };
}

export const GetPreferredPackageVersionRequest: MessageFns<GetPreferredPackageVersionRequest> = {
  encode(message: GetPreferredPackageVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parties) {
      writer.uint32(10).string(v!);
    }
    if (message.packageName !== "") {
      writer.uint32(18).string(message.packageName);
    }
    if (message.synchronizerId !== "") {
      writer.uint32(26).string(message.synchronizerId);
    }
    if (message.vettingValidAt !== undefined) {
      Timestamp.encode(toTimestamp(message.vettingValidAt), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreferredPackageVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreferredPackageVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parties.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vettingValidAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreferredPackageVersionRequest {
    return {
      parties: gt.Array.isArray(object?.parties) ? object.parties.map((e: any) => gt.String(e)) : [],
      packageName: isSet(object.packageName) ? gt.String(object.packageName) : "",
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
      vettingValidAt: isSet(object.vettingValidAt) ? fromJsonTimestamp(object.vettingValidAt) : undefined,
    };
  },

  toJSON(message: GetPreferredPackageVersionRequest): unknown {
    const obj: any = {};
    if (message.parties?.length) {
      obj.parties = message.parties;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    if (message.vettingValidAt !== undefined) {
      obj.vettingValidAt = message.vettingValidAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPreferredPackageVersionRequest>, I>>(
    base?: I,
  ): GetPreferredPackageVersionRequest {
    return GetPreferredPackageVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPreferredPackageVersionRequest>, I>>(
    object: I,
  ): GetPreferredPackageVersionRequest {
    const message = createBaseGetPreferredPackageVersionRequest();
    message.parties = object.parties?.map((e) => e) || [];
    message.packageName = object.packageName ?? "";
    message.synchronizerId = object.synchronizerId ?? "";
    message.vettingValidAt = object.vettingValidAt ?? undefined;
    return message;
  },
};

function createBaseGetPreferredPackageVersionResponse(): GetPreferredPackageVersionResponse {
  return { packagePreference: undefined };
}

export const GetPreferredPackageVersionResponse: MessageFns<GetPreferredPackageVersionResponse> = {
  encode(message: GetPreferredPackageVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packagePreference !== undefined) {
      PackagePreference.encode(message.packagePreference, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreferredPackageVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreferredPackageVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packagePreference = PackagePreference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreferredPackageVersionResponse {
    return {
      packagePreference: isSet(object.packagePreference)
        ? PackagePreference.fromJSON(object.packagePreference)
        : undefined,
    };
  },

  toJSON(message: GetPreferredPackageVersionResponse): unknown {
    const obj: any = {};
    if (message.packagePreference !== undefined) {
      obj.packagePreference = PackagePreference.toJSON(message.packagePreference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPreferredPackageVersionResponse>, I>>(
    base?: I,
  ): GetPreferredPackageVersionResponse {
    return GetPreferredPackageVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPreferredPackageVersionResponse>, I>>(
    object: I,
  ): GetPreferredPackageVersionResponse {
    const message = createBaseGetPreferredPackageVersionResponse();
    message.packagePreference = (object.packagePreference !== undefined && object.packagePreference !== null)
      ? PackagePreference.fromPartial(object.packagePreference)
      : undefined;
    return message;
  },
};

function createBasePackagePreference(): PackagePreference {
  return { packageReference: undefined, synchronizerId: "" };
}

export const PackagePreference: MessageFns<PackagePreference> = {
  encode(message: PackagePreference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageReference !== undefined) {
      PackageReference.encode(message.packageReference, writer.uint32(10).fork()).join();
    }
    if (message.synchronizerId !== "") {
      writer.uint32(18).string(message.synchronizerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackagePreference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackagePreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packageReference = PackageReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.synchronizerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackagePreference {
    return {
      packageReference: isSet(object.packageReference) ? PackageReference.fromJSON(object.packageReference) : undefined,
      synchronizerId: isSet(object.synchronizerId) ? gt.String(object.synchronizerId) : "",
    };
  },

  toJSON(message: PackagePreference): unknown {
    const obj: any = {};
    if (message.packageReference !== undefined) {
      obj.packageReference = PackageReference.toJSON(message.packageReference);
    }
    if (message.synchronizerId !== "") {
      obj.synchronizerId = message.synchronizerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PackagePreference>, I>>(base?: I): PackagePreference {
    return PackagePreference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PackagePreference>, I>>(object: I): PackagePreference {
    const message = createBasePackagePreference();
    message.packageReference = (object.packageReference !== undefined && object.packageReference !== null)
      ? PackageReference.fromPartial(object.packageReference)
      : undefined;
    message.synchronizerId = object.synchronizerId ?? "";
    return message;
  },
};

/**
 * Service allowing interactive construction of command submissions
 *
 * The prepare and execute endpoints allow to submit commands in 2-steps:
 *
 * 1. prepare transaction from commands,
 * 2. submit the prepared transaction
 *
 * This gives callers the ability to sign the daml transaction with their own signing keys
 */
export interface InteractiveSubmissionService {
  /** Requires `readAs` scope for the submitting party when LAPI User authorization is enabled */
  PrepareSubmission(request: PrepareSubmissionRequest): Promise<PrepareSubmissionResponse>;
  ExecuteSubmission(request: ExecuteSubmissionRequest): Promise<ExecuteSubmissionResponse>;
  /**
   * A preferred package is the highest-versioned package for a provided package-name
   * that is vetted by all the participants hosting the provided parties.
   *
   * Ledger API clients should use this endpoint for constructing command submissions
   * that are compatible with the provided preferred package, by making informed decisions on:
   * - which are the compatible packages that can be used to create contracts
   * - which contract or exercise choice argument version can be used in the command
   * - which choices can be executed on a template or interface of a contract
   *
   * Can be accessed by any Ledger API client with a valid token when Ledger API authorization is enabled.
   *
   * Experimental API: this endpoint is not guaranteed to provide backwards compatibility in future releases
   */
  GetPreferredPackageVersion(request: GetPreferredPackageVersionRequest): Promise<GetPreferredPackageVersionResponse>;
}

export const InteractiveSubmissionServiceServiceName =
  "com.daml.ledger.api.v2.interactive.InteractiveSubmissionService";
export class InteractiveSubmissionServiceClientImpl implements InteractiveSubmissionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || InteractiveSubmissionServiceServiceName;
    this.rpc = rpc;
    this.PrepareSubmission = this.PrepareSubmission.bind(this);
    this.ExecuteSubmission = this.ExecuteSubmission.bind(this);
    this.GetPreferredPackageVersion = this.GetPreferredPackageVersion.bind(this);
  }
  PrepareSubmission(request: PrepareSubmissionRequest): Promise<PrepareSubmissionResponse> {
    const data = PrepareSubmissionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PrepareSubmission", data);
    return promise.then((data) => PrepareSubmissionResponse.decode(new BinaryReader(data)));
  }

  ExecuteSubmission(request: ExecuteSubmissionRequest): Promise<ExecuteSubmissionResponse> {
    const data = ExecuteSubmissionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExecuteSubmission", data);
    return promise.then((data) => ExecuteSubmissionResponse.decode(new BinaryReader(data)));
  }

  GetPreferredPackageVersion(request: GetPreferredPackageVersionRequest): Promise<GetPreferredPackageVersionResponse> {
    const data = GetPreferredPackageVersionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreferredPackageVersion", data);
    return promise.then((data) => GetPreferredPackageVersionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  const bin = gt.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(gt.String.fromCharCode(byte));
  });
  return gt.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new gt.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof gt.Date) {
    return o;
  } else if (typeof o === "string") {
    return new gt.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
