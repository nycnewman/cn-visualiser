// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/interactive/transaction/v1/interactive_submission_data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Identifier, Value } from "../../../value";

export const protobufPackage = "com.daml.ledger.api.v2.interactive.transaction.v1";

/** Fetch node */
export interface Fetch {
  /** Specific LF version of the node */
  lfVersion: string;
  contractId: string;
  packageName: string;
  /** The identifier uses the package-id reference format. */
  templateId: Identifier | undefined;
  signatories: string[];
  stakeholders: string[];
  actingParties: string[];
  /** Optional */
  interfaceId: Identifier | undefined;
}

/** Exercise node */
export interface Exercise {
  /** Specific LF version of the node */
  lfVersion: string;
  contractId: string;
  packageName: string;
  /** The identifier uses the package-id reference format. */
  templateId: Identifier | undefined;
  signatories: string[];
  stakeholders: string[];
  actingParties: string[];
  /** The identifier uses the package-id reference format. */
  interfaceId: Identifier | undefined;
  choiceId: string;
  chosenValue: Value | undefined;
  consuming: boolean;
  children: string[];
  exerciseResult: Value | undefined;
  choiceObservers: string[];
}

/** Create Node */
export interface Create {
  /** Specific LF version of the node */
  lfVersion: string;
  contractId: string;
  packageName: string;
  /** The identifier uses the package-id reference format. */
  templateId: Identifier | undefined;
  argument: Value | undefined;
  signatories: string[];
  stakeholders: string[];
}

/** Rollback Node */
export interface Rollback {
  children: string[];
}

export interface Node {
  create?: Create | undefined;
  fetch?: Fetch | undefined;
  exercise?: Exercise | undefined;
  rollback?: Rollback | undefined;
}

function createBaseFetch(): Fetch {
  return {
    lfVersion: "",
    contractId: "",
    packageName: "",
    templateId: undefined,
    signatories: [],
    stakeholders: [],
    actingParties: [],
    interfaceId: undefined,
  };
}

export const Fetch: MessageFns<Fetch> = {
  encode(message: Fetch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lfVersion !== "") {
      writer.uint32(10).string(message.lfVersion);
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.packageName !== "") {
      writer.uint32(26).string(message.packageName);
    }
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(34).fork()).join();
    }
    for (const v of message.signatories) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.stakeholders) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.actingParties) {
      writer.uint32(58).string(v!);
    }
    if (message.interfaceId !== undefined) {
      Identifier.encode(message.interfaceId, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fetch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lfVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signatories.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stakeholders.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.actingParties.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.interfaceId = Identifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fetch {
    return {
      lfVersion: isSet(object.lfVersion) ? gt.String(object.lfVersion) : "",
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      packageName: isSet(object.packageName) ? gt.String(object.packageName) : "",
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      signatories: gt.Array.isArray(object?.signatories) ? object.signatories.map((e: any) => gt.String(e)) : [],
      stakeholders: gt.Array.isArray(object?.stakeholders) ? object.stakeholders.map((e: any) => gt.String(e)) : [],
      actingParties: gt.Array.isArray(object?.actingParties) ? object.actingParties.map((e: any) => gt.String(e)) : [],
      interfaceId: isSet(object.interfaceId) ? Identifier.fromJSON(object.interfaceId) : undefined,
    };
  },

  toJSON(message: Fetch): unknown {
    const obj: any = {};
    if (message.lfVersion !== "") {
      obj.lfVersion = message.lfVersion;
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.signatories?.length) {
      obj.signatories = message.signatories;
    }
    if (message.stakeholders?.length) {
      obj.stakeholders = message.stakeholders;
    }
    if (message.actingParties?.length) {
      obj.actingParties = message.actingParties;
    }
    if (message.interfaceId !== undefined) {
      obj.interfaceId = Identifier.toJSON(message.interfaceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fetch>, I>>(base?: I): Fetch {
    return Fetch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fetch>, I>>(object: I): Fetch {
    const message = createBaseFetch();
    message.lfVersion = object.lfVersion ?? "";
    message.contractId = object.contractId ?? "";
    message.packageName = object.packageName ?? "";
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.signatories = object.signatories?.map((e) => e) || [];
    message.stakeholders = object.stakeholders?.map((e) => e) || [];
    message.actingParties = object.actingParties?.map((e) => e) || [];
    message.interfaceId = (object.interfaceId !== undefined && object.interfaceId !== null)
      ? Identifier.fromPartial(object.interfaceId)
      : undefined;
    return message;
  },
};

function createBaseExercise(): Exercise {
  return {
    lfVersion: "",
    contractId: "",
    packageName: "",
    templateId: undefined,
    signatories: [],
    stakeholders: [],
    actingParties: [],
    interfaceId: undefined,
    choiceId: "",
    chosenValue: undefined,
    consuming: false,
    children: [],
    exerciseResult: undefined,
    choiceObservers: [],
  };
}

export const Exercise: MessageFns<Exercise> = {
  encode(message: Exercise, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lfVersion !== "") {
      writer.uint32(10).string(message.lfVersion);
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.packageName !== "") {
      writer.uint32(26).string(message.packageName);
    }
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(34).fork()).join();
    }
    for (const v of message.signatories) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.stakeholders) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.actingParties) {
      writer.uint32(58).string(v!);
    }
    if (message.interfaceId !== undefined) {
      Identifier.encode(message.interfaceId, writer.uint32(66).fork()).join();
    }
    if (message.choiceId !== "") {
      writer.uint32(74).string(message.choiceId);
    }
    if (message.chosenValue !== undefined) {
      Value.encode(message.chosenValue, writer.uint32(82).fork()).join();
    }
    if (message.consuming !== false) {
      writer.uint32(88).bool(message.consuming);
    }
    for (const v of message.children) {
      writer.uint32(98).string(v!);
    }
    if (message.exerciseResult !== undefined) {
      Value.encode(message.exerciseResult, writer.uint32(106).fork()).join();
    }
    for (const v of message.choiceObservers) {
      writer.uint32(114).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exercise {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExercise();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lfVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signatories.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stakeholders.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.actingParties.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.interfaceId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.choiceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chosenValue = Value.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.consuming = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.children.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.exerciseResult = Value.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.choiceObservers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exercise {
    return {
      lfVersion: isSet(object.lfVersion) ? gt.String(object.lfVersion) : "",
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      packageName: isSet(object.packageName) ? gt.String(object.packageName) : "",
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      signatories: gt.Array.isArray(object?.signatories) ? object.signatories.map((e: any) => gt.String(e)) : [],
      stakeholders: gt.Array.isArray(object?.stakeholders) ? object.stakeholders.map((e: any) => gt.String(e)) : [],
      actingParties: gt.Array.isArray(object?.actingParties) ? object.actingParties.map((e: any) => gt.String(e)) : [],
      interfaceId: isSet(object.interfaceId) ? Identifier.fromJSON(object.interfaceId) : undefined,
      choiceId: isSet(object.choiceId) ? gt.String(object.choiceId) : "",
      chosenValue: isSet(object.chosenValue) ? Value.fromJSON(object.chosenValue) : undefined,
      consuming: isSet(object.consuming) ? gt.Boolean(object.consuming) : false,
      children: gt.Array.isArray(object?.children) ? object.children.map((e: any) => gt.String(e)) : [],
      exerciseResult: isSet(object.exerciseResult) ? Value.fromJSON(object.exerciseResult) : undefined,
      choiceObservers: gt.Array.isArray(object?.choiceObservers)
        ? object.choiceObservers.map((e: any) => gt.String(e))
        : [],
    };
  },

  toJSON(message: Exercise): unknown {
    const obj: any = {};
    if (message.lfVersion !== "") {
      obj.lfVersion = message.lfVersion;
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.signatories?.length) {
      obj.signatories = message.signatories;
    }
    if (message.stakeholders?.length) {
      obj.stakeholders = message.stakeholders;
    }
    if (message.actingParties?.length) {
      obj.actingParties = message.actingParties;
    }
    if (message.interfaceId !== undefined) {
      obj.interfaceId = Identifier.toJSON(message.interfaceId);
    }
    if (message.choiceId !== "") {
      obj.choiceId = message.choiceId;
    }
    if (message.chosenValue !== undefined) {
      obj.chosenValue = Value.toJSON(message.chosenValue);
    }
    if (message.consuming !== false) {
      obj.consuming = message.consuming;
    }
    if (message.children?.length) {
      obj.children = message.children;
    }
    if (message.exerciseResult !== undefined) {
      obj.exerciseResult = Value.toJSON(message.exerciseResult);
    }
    if (message.choiceObservers?.length) {
      obj.choiceObservers = message.choiceObservers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exercise>, I>>(base?: I): Exercise {
    return Exercise.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exercise>, I>>(object: I): Exercise {
    const message = createBaseExercise();
    message.lfVersion = object.lfVersion ?? "";
    message.contractId = object.contractId ?? "";
    message.packageName = object.packageName ?? "";
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.signatories = object.signatories?.map((e) => e) || [];
    message.stakeholders = object.stakeholders?.map((e) => e) || [];
    message.actingParties = object.actingParties?.map((e) => e) || [];
    message.interfaceId = (object.interfaceId !== undefined && object.interfaceId !== null)
      ? Identifier.fromPartial(object.interfaceId)
      : undefined;
    message.choiceId = object.choiceId ?? "";
    message.chosenValue = (object.chosenValue !== undefined && object.chosenValue !== null)
      ? Value.fromPartial(object.chosenValue)
      : undefined;
    message.consuming = object.consuming ?? false;
    message.children = object.children?.map((e) => e) || [];
    message.exerciseResult = (object.exerciseResult !== undefined && object.exerciseResult !== null)
      ? Value.fromPartial(object.exerciseResult)
      : undefined;
    message.choiceObservers = object.choiceObservers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreate(): Create {
  return {
    lfVersion: "",
    contractId: "",
    packageName: "",
    templateId: undefined,
    argument: undefined,
    signatories: [],
    stakeholders: [],
  };
}

export const Create: MessageFns<Create> = {
  encode(message: Create, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lfVersion !== "") {
      writer.uint32(10).string(message.lfVersion);
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.packageName !== "") {
      writer.uint32(26).string(message.packageName);
    }
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(34).fork()).join();
    }
    if (message.argument !== undefined) {
      Value.encode(message.argument, writer.uint32(42).fork()).join();
    }
    for (const v of message.signatories) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.stakeholders) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Create {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lfVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.argument = Value.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signatories.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stakeholders.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Create {
    return {
      lfVersion: isSet(object.lfVersion) ? gt.String(object.lfVersion) : "",
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      packageName: isSet(object.packageName) ? gt.String(object.packageName) : "",
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      argument: isSet(object.argument) ? Value.fromJSON(object.argument) : undefined,
      signatories: gt.Array.isArray(object?.signatories) ? object.signatories.map((e: any) => gt.String(e)) : [],
      stakeholders: gt.Array.isArray(object?.stakeholders) ? object.stakeholders.map((e: any) => gt.String(e)) : [],
    };
  },

  toJSON(message: Create): unknown {
    const obj: any = {};
    if (message.lfVersion !== "") {
      obj.lfVersion = message.lfVersion;
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.argument !== undefined) {
      obj.argument = Value.toJSON(message.argument);
    }
    if (message.signatories?.length) {
      obj.signatories = message.signatories;
    }
    if (message.stakeholders?.length) {
      obj.stakeholders = message.stakeholders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Create>, I>>(base?: I): Create {
    return Create.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Create>, I>>(object: I): Create {
    const message = createBaseCreate();
    message.lfVersion = object.lfVersion ?? "";
    message.contractId = object.contractId ?? "";
    message.packageName = object.packageName ?? "";
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.argument = (object.argument !== undefined && object.argument !== null)
      ? Value.fromPartial(object.argument)
      : undefined;
    message.signatories = object.signatories?.map((e) => e) || [];
    message.stakeholders = object.stakeholders?.map((e) => e) || [];
    return message;
  },
};

function createBaseRollback(): Rollback {
  return { children: [] };
}

export const Rollback: MessageFns<Rollback> = {
  encode(message: Rollback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rollback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rollback {
    return { children: gt.Array.isArray(object?.children) ? object.children.map((e: any) => gt.String(e)) : [] };
  },

  toJSON(message: Rollback): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rollback>, I>>(base?: I): Rollback {
    return Rollback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rollback>, I>>(object: I): Rollback {
    const message = createBaseRollback();
    message.children = object.children?.map((e) => e) || [];
    return message;
  },
};

function createBaseNode(): Node {
  return { create: undefined, fetch: undefined, exercise: undefined, rollback: undefined };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create !== undefined) {
      Create.encode(message.create, writer.uint32(10).fork()).join();
    }
    if (message.fetch !== undefined) {
      Fetch.encode(message.fetch, writer.uint32(18).fork()).join();
    }
    if (message.exercise !== undefined) {
      Exercise.encode(message.exercise, writer.uint32(26).fork()).join();
    }
    if (message.rollback !== undefined) {
      Rollback.encode(message.rollback, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.create = Create.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fetch = Fetch.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exercise = Exercise.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rollback = Rollback.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      create: isSet(object.create) ? Create.fromJSON(object.create) : undefined,
      fetch: isSet(object.fetch) ? Fetch.fromJSON(object.fetch) : undefined,
      exercise: isSet(object.exercise) ? Exercise.fromJSON(object.exercise) : undefined,
      rollback: isSet(object.rollback) ? Rollback.fromJSON(object.rollback) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.create !== undefined) {
      obj.create = Create.toJSON(message.create);
    }
    if (message.fetch !== undefined) {
      obj.fetch = Fetch.toJSON(message.fetch);
    }
    if (message.exercise !== undefined) {
      obj.exercise = Exercise.toJSON(message.exercise);
    }
    if (message.rollback !== undefined) {
      obj.rollback = Rollback.toJSON(message.rollback);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.create = (object.create !== undefined && object.create !== null)
      ? Create.fromPartial(object.create)
      : undefined;
    message.fetch = (object.fetch !== undefined && object.fetch !== null) ? Fetch.fromPartial(object.fetch) : undefined;
    message.exercise = (object.exercise !== undefined && object.exercise !== null)
      ? Exercise.fromPartial(object.exercise)
      : undefined;
    message.rollback = (object.rollback !== undefined && object.rollback !== null)
      ? Rollback.fromPartial(object.rollback)
      : undefined;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
