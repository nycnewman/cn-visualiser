// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: com/daml/ledger/api/v2/reassignment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../../google/protobuf/timestamp";
import { CreatedEvent } from "./event";
import { TraceContext } from "./trace_context";
import { Identifier } from "./value";

export const protobufPackage = "com.daml.ledger.api.v2";

/** Complete view of an on-ledger reassignment. */
export interface Reassignment {
  /**
   * Assigned by the server. Useful for correlating logs.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  updateId: string;
  /**
   * The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Optional
   */
  commandId: string;
  /**
   * The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Optional
   */
  workflowId: string;
  /**
   * The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
   * Required, must be a valid absolute offset (positive integer).
   */
  offset: number;
  /** The collection of reassignment events. Required. */
  events: ReassignmentEvent[];
  /**
   * Optional; ledger API trace context
   *
   * The trace context transported in this message corresponds to the trace context supplied
   * by the client application in a HTTP2 header of the original command submission.
   * We typically use a header to transfer this type of information. Here we use message
   * body, because it is used in gRPC streams which do not support per message headers.
   * This field will be populated with the trace context contained in the original submission.
   * If that was not provided, a unique ledger-api-server generated trace context will be used
   * instead.
   */
  traceContext:
    | TraceContext
    | undefined;
  /**
   * The time at which the reassignment was recorded. The record time refers to the source/target
   * synchronizer for an unassign/assign event respectively.
   * Required
   */
  recordTime: Date | undefined;
}

export interface ReassignmentEvent {
  unassigned?: UnassignedEvent | undefined;
  assigned?: AssignedEvent | undefined;
}

/** Records that a contract has been unassigned, and it becomes unusable on the source synchronizer */
export interface UnassignedEvent {
  /**
   * The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
   * For one contract the (unassign_id, source synchronizer) pair is unique.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  unassignId: string;
  /**
   * The ID of the reassigned contract.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  contractId: string;
  /**
   * The template of the reassigned contract.
   * The identifier uses the package-id reference format.
   *
   * Required
   */
  templateId:
    | Identifier
    | undefined;
  /**
   * The ID of the source synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  source: string;
  /**
   * The ID of the target synchronizer
   * Must be a valid synchronizer id
   * Required
   */
  target: string;
  /**
   * Party on whose behalf the unassign command was executed.
   * Empty if the unassignment happened offline via the repair service.
   * Must be a valid PartyIdString (as described in ``value.proto``).
   * Optional
   */
  submitter: string;
  /**
   * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
   * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
   * equals zero.
   * Required
   */
  reassignmentCounter: number;
  /**
   * Assignment exclusivity
   * Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
   * Defined for reassigning participants.
   * Optional
   */
  assignmentExclusivity:
    | Date
    | undefined;
  /**
   * The parties that are notified of this event.
   * Required
   */
  witnessParties: string[];
  /**
   * The package name of the contract.
   * Required
   */
  packageName: string;
  /**
   * The offset of origin.
   * Offsets are managed by the participant nodes.
   * Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
   * Required, it is a valid absolute offset (positive integer)
   */
  offset: number;
  /**
   * The position of this event in the originating reassignment.
   * Node IDs are not necessarily equal across participants,
   * as these may see different projections/parts of reassignments.
   * Required, must be valid node ID (non-negative integer)
   */
  nodeId: number;
}

/** Records that a contract has been assigned, and it can be used on the target synchronizer. */
export interface AssignedEvent {
  /**
   * The ID of the source synchronizer.
   * Must be a valid synchronizer id.
   * Required
   */
  source: string;
  /**
   * The ID of the target synchronizer.
   * Must be a valid synchronizer id.
   * Required
   */
  target: string;
  /**
   * The ID from the unassigned event.
   * For correlation capabilities.
   * For one contract the (unassign_id, source synchronizer) pair is unique.
   * Must be a valid LedgerString (as described in ``value.proto``).
   * Required
   */
  unassignId: string;
  /**
   * Party on whose behalf the assign command was executed.
   * Empty if the assignment happened offline via the repair service.
   * Must be a valid PartyIdString (as described in ``value.proto``).
   * Optional
   */
  submitter: string;
  /**
   * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
   * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
   * equals zero.
   * Required
   */
  reassignmentCounter: number;
  /**
   * Required
   * The offset of this event refers to the offset of the assignment,
   * while the node_id is the index of within the batch.
   */
  createdEvent: CreatedEvent | undefined;
}

function createBaseReassignment(): Reassignment {
  return {
    updateId: "",
    commandId: "",
    workflowId: "",
    offset: 0,
    events: [],
    traceContext: undefined,
    recordTime: undefined,
  };
}

export const Reassignment: MessageFns<Reassignment> = {
  encode(message: Reassignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.commandId !== "") {
      writer.uint32(18).string(message.commandId);
    }
    if (message.workflowId !== "") {
      writer.uint32(26).string(message.workflowId);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int64(message.offset);
    }
    for (const v of message.events) {
      ReassignmentEvent.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(50).fork()).join();
    }
    if (message.recordTime !== undefined) {
      Timestamp.encode(toTimestamp(message.recordTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reassignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReassignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.events.push(ReassignmentEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recordTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reassignment {
    return {
      updateId: isSet(object.updateId) ? gt.String(object.updateId) : "",
      commandId: isSet(object.commandId) ? gt.String(object.commandId) : "",
      workflowId: isSet(object.workflowId) ? gt.String(object.workflowId) : "",
      offset: isSet(object.offset) ? gt.Number(object.offset) : 0,
      events: gt.Array.isArray(object?.events) ? object.events.map((e: any) => ReassignmentEvent.fromJSON(e)) : [],
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      recordTime: isSet(object.recordTime) ? fromJsonTimestamp(object.recordTime) : undefined,
    };
  },

  toJSON(message: Reassignment): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => ReassignmentEvent.toJSON(e));
    }
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.recordTime !== undefined) {
      obj.recordTime = message.recordTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reassignment>, I>>(base?: I): Reassignment {
    return Reassignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reassignment>, I>>(object: I): Reassignment {
    const message = createBaseReassignment();
    message.updateId = object.updateId ?? "";
    message.commandId = object.commandId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.offset = object.offset ?? 0;
    message.events = object.events?.map((e) => ReassignmentEvent.fromPartial(e)) || [];
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.recordTime = object.recordTime ?? undefined;
    return message;
  },
};

function createBaseReassignmentEvent(): ReassignmentEvent {
  return { unassigned: undefined, assigned: undefined };
}

export const ReassignmentEvent: MessageFns<ReassignmentEvent> = {
  encode(message: ReassignmentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unassigned !== undefined) {
      UnassignedEvent.encode(message.unassigned, writer.uint32(10).fork()).join();
    }
    if (message.assigned !== undefined) {
      AssignedEvent.encode(message.assigned, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReassignmentEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReassignmentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unassigned = UnassignedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assigned = AssignedEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReassignmentEvent {
    return {
      unassigned: isSet(object.unassigned) ? UnassignedEvent.fromJSON(object.unassigned) : undefined,
      assigned: isSet(object.assigned) ? AssignedEvent.fromJSON(object.assigned) : undefined,
    };
  },

  toJSON(message: ReassignmentEvent): unknown {
    const obj: any = {};
    if (message.unassigned !== undefined) {
      obj.unassigned = UnassignedEvent.toJSON(message.unassigned);
    }
    if (message.assigned !== undefined) {
      obj.assigned = AssignedEvent.toJSON(message.assigned);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReassignmentEvent>, I>>(base?: I): ReassignmentEvent {
    return ReassignmentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReassignmentEvent>, I>>(object: I): ReassignmentEvent {
    const message = createBaseReassignmentEvent();
    message.unassigned = (object.unassigned !== undefined && object.unassigned !== null)
      ? UnassignedEvent.fromPartial(object.unassigned)
      : undefined;
    message.assigned = (object.assigned !== undefined && object.assigned !== null)
      ? AssignedEvent.fromPartial(object.assigned)
      : undefined;
    return message;
  },
};

function createBaseUnassignedEvent(): UnassignedEvent {
  return {
    unassignId: "",
    contractId: "",
    templateId: undefined,
    source: "",
    target: "",
    submitter: "",
    reassignmentCounter: 0,
    assignmentExclusivity: undefined,
    witnessParties: [],
    packageName: "",
    offset: 0,
    nodeId: 0,
  };
}

export const UnassignedEvent: MessageFns<UnassignedEvent> = {
  encode(message: UnassignedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unassignId !== "") {
      writer.uint32(10).string(message.unassignId);
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.templateId !== undefined) {
      Identifier.encode(message.templateId, writer.uint32(26).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(42).string(message.target);
    }
    if (message.submitter !== "") {
      writer.uint32(50).string(message.submitter);
    }
    if (message.reassignmentCounter !== 0) {
      writer.uint32(56).uint64(message.reassignmentCounter);
    }
    if (message.assignmentExclusivity !== undefined) {
      Timestamp.encode(toTimestamp(message.assignmentExclusivity), writer.uint32(66).fork()).join();
    }
    for (const v of message.witnessParties) {
      writer.uint32(74).string(v!);
    }
    if (message.packageName !== "") {
      writer.uint32(82).string(message.packageName);
    }
    if (message.offset !== 0) {
      writer.uint32(88).int64(message.offset);
    }
    if (message.nodeId !== 0) {
      writer.uint32(96).int32(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnassignedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnassignedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unassignId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.templateId = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.reassignmentCounter = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.assignmentExclusivity = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.witnessParties.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.nodeId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnassignedEvent {
    return {
      unassignId: isSet(object.unassignId) ? gt.String(object.unassignId) : "",
      contractId: isSet(object.contractId) ? gt.String(object.contractId) : "",
      templateId: isSet(object.templateId) ? Identifier.fromJSON(object.templateId) : undefined,
      source: isSet(object.source) ? gt.String(object.source) : "",
      target: isSet(object.target) ? gt.String(object.target) : "",
      submitter: isSet(object.submitter) ? gt.String(object.submitter) : "",
      reassignmentCounter: isSet(object.reassignmentCounter) ? gt.Number(object.reassignmentCounter) : 0,
      assignmentExclusivity: isSet(object.assignmentExclusivity)
        ? fromJsonTimestamp(object.assignmentExclusivity)
        : undefined,
      witnessParties: gt.Array.isArray(object?.witnessParties)
        ? object.witnessParties.map((e: any) => gt.String(e))
        : [],
      packageName: isSet(object.packageName) ? gt.String(object.packageName) : "",
      offset: isSet(object.offset) ? gt.Number(object.offset) : 0,
      nodeId: isSet(object.nodeId) ? gt.Number(object.nodeId) : 0,
    };
  },

  toJSON(message: UnassignedEvent): unknown {
    const obj: any = {};
    if (message.unassignId !== "") {
      obj.unassignId = message.unassignId;
    }
    if (message.contractId !== "") {
      obj.contractId = message.contractId;
    }
    if (message.templateId !== undefined) {
      obj.templateId = Identifier.toJSON(message.templateId);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.reassignmentCounter !== 0) {
      obj.reassignmentCounter = Math.round(message.reassignmentCounter);
    }
    if (message.assignmentExclusivity !== undefined) {
      obj.assignmentExclusivity = message.assignmentExclusivity.toISOString();
    }
    if (message.witnessParties?.length) {
      obj.witnessParties = message.witnessParties;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnassignedEvent>, I>>(base?: I): UnassignedEvent {
    return UnassignedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnassignedEvent>, I>>(object: I): UnassignedEvent {
    const message = createBaseUnassignedEvent();
    message.unassignId = object.unassignId ?? "";
    message.contractId = object.contractId ?? "";
    message.templateId = (object.templateId !== undefined && object.templateId !== null)
      ? Identifier.fromPartial(object.templateId)
      : undefined;
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.submitter = object.submitter ?? "";
    message.reassignmentCounter = object.reassignmentCounter ?? 0;
    message.assignmentExclusivity = object.assignmentExclusivity ?? undefined;
    message.witnessParties = object.witnessParties?.map((e) => e) || [];
    message.packageName = object.packageName ?? "";
    message.offset = object.offset ?? 0;
    message.nodeId = object.nodeId ?? 0;
    return message;
  },
};

function createBaseAssignedEvent(): AssignedEvent {
  return { source: "", target: "", unassignId: "", submitter: "", reassignmentCounter: 0, createdEvent: undefined };
}

export const AssignedEvent: MessageFns<AssignedEvent> = {
  encode(message: AssignedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.unassignId !== "") {
      writer.uint32(26).string(message.unassignId);
    }
    if (message.submitter !== "") {
      writer.uint32(34).string(message.submitter);
    }
    if (message.reassignmentCounter !== 0) {
      writer.uint32(40).uint64(message.reassignmentCounter);
    }
    if (message.createdEvent !== undefined) {
      CreatedEvent.encode(message.createdEvent, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unassignId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reassignmentCounter = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdEvent = CreatedEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignedEvent {
    return {
      source: isSet(object.source) ? gt.String(object.source) : "",
      target: isSet(object.target) ? gt.String(object.target) : "",
      unassignId: isSet(object.unassignId) ? gt.String(object.unassignId) : "",
      submitter: isSet(object.submitter) ? gt.String(object.submitter) : "",
      reassignmentCounter: isSet(object.reassignmentCounter) ? gt.Number(object.reassignmentCounter) : 0,
      createdEvent: isSet(object.createdEvent) ? CreatedEvent.fromJSON(object.createdEvent) : undefined,
    };
  },

  toJSON(message: AssignedEvent): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.unassignId !== "") {
      obj.unassignId = message.unassignId;
    }
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.reassignmentCounter !== 0) {
      obj.reassignmentCounter = Math.round(message.reassignmentCounter);
    }
    if (message.createdEvent !== undefined) {
      obj.createdEvent = CreatedEvent.toJSON(message.createdEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignedEvent>, I>>(base?: I): AssignedEvent {
    return AssignedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignedEvent>, I>>(object: I): AssignedEvent {
    const message = createBaseAssignedEvent();
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.unassignId = object.unassignId ?? "";
    message.submitter = object.submitter ?? "";
    message.reassignmentCounter = object.reassignmentCounter ?? 0;
    message.createdEvent = (object.createdEvent !== undefined && object.createdEvent !== null)
      ? CreatedEvent.fromPartial(object.createdEvent)
      : undefined;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new gt.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof gt.Date) {
    return o;
  } else if (typeof o === "string") {
    return new gt.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = gt.Number(int64.toString());
  if (num > gt.Number.MAX_SAFE_INTEGER) {
    throw new gt.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < gt.Number.MIN_SAFE_INTEGER) {
    throw new gt.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
